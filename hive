#!/usr/bin/env bash
set -euo pipefail

VERSION="0.2.2"
SCRIPT_NAME="hive"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Timing parameters
DEBOUNCE_SECONDS=10
SETTLE_SECONDS=5
GITHUB_POLL_INTERVAL=60
MAX_RETRIES=60
RETRY_INTERVAL=2

# GitHub cache
_GH_ITEMS_CACHE=""
_GH_ITEMS_CACHE_TIME=0

# Default messages (can be overridden in .hive.yaml)
DEFAULT_STARTUP_MSG="Read .hive/workers/{lane}/WORKER.md if it exists. You are assigned to lane '{lane}'. Check your task backlog. If backlog is EMPTY, report 'No tasks in backlog for {lane}' and STOP - do NOT explore or look for other work. If tasks exist, claim ONE task and work on it. When finished, create a git branch, commit, push, and create a Pull Request."

DEFAULT_NUDGE_MSG="FIRST: If you have uncommitted changes or an unpushed branch from a previous task, you MUST create a PR NOW using 'gh pr create' before starting anything new. You have {backlog_count} task(s) in your backlog for lane '{lane}'. Claim ONE task and work on it. REMINDER: When done, create a branch, commit, push, and run 'gh pr create' - do NOT stop until the PR URL is displayed."

#------------------------------------------------------------------------------
# Utility functions
#------------------------------------------------------------------------------

log_info() { echo -e "${BLUE}[info]${NC} $*"; }
log_ok() { echo -e "${GREEN}[ok]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[warn]${NC} $*"; }
log_error() { echo -e "${RED}[error]${NC} $*" >&2; }

# Portable lowercase (works in bash 3, zsh, etc.)
lowercase() { echo "$1" | tr '[:upper:]' '[:lower:]'; }

# Escape a string for YAML double-quoted output
yaml_escape() {
  local str="$1"
  str="${str//\\/\\\\}"  # Escape backslashes first
  str="${str//\"/\\\"}"  # Escape double quotes
  echo "$str"
}

# Ensure .hive/ is in .git/info/exclude (silent, idempotent)
ensure_git_exclude() {
  local project_dir="$1"

  # Handle both regular repos (.git is dir) and worktrees (.git is file)
  [[ ! -e "$project_dir/.git" ]] && return 0

  local exclude_file="$project_dir/.git/info/exclude"

  # For worktrees, .git is a file - resolve to actual git dir
  if [[ -f "$project_dir/.git" ]]; then
    local git_dir
    git_dir=$(cat "$project_dir/.git" | sed 's/^gitdir: //')
    # Go up from worktrees/<name> to main .git
    exclude_file="$(dirname "$(dirname "$git_dir")")/info/exclude"
  fi

  # Already set up?
  grep -qxF ".hive/" "$exclude_file" 2>/dev/null && return 0

  mkdir -p "$(dirname "$exclude_file")"
  {
    echo ""
    echo "# Hive - AI worker orchestration"
    echo ".hive/"
  } >> "$exclude_file"
}

# Check if gum is available for fancy prompts
has_gum() { command -v gum &>/dev/null; }

# Run gum command, exit on Ctrl+C
run_gum() {
  local result
  if result=$("$@"); then
    echo "$result"
  else
    local exit_code=$?
    # Exit code 130 = SIGINT (Ctrl+C), 1 = user cancelled
    if [[ $exit_code -eq 130 || $exit_code -eq 1 ]]; then
      echo ""
      log_warn "Cancelled"
      exit 130
    fi
    return $exit_code
  fi
}

#------------------------------------------------------------------------------
# Interactive prompt helpers (gum with fallback)
#------------------------------------------------------------------------------

# Confirm yes/no prompt. Returns 0 for yes, 1 for no.
# Usage: prompt_confirm "Question?" && echo "yes"
prompt_confirm() {
  local prompt="$1"
  local default="${2:-n}"  # y or n

  if has_gum; then
    if [[ "$default" == "y" ]]; then
      gum confirm --default=yes "$prompt" || {
        [[ $? -eq 130 ]] && { echo ""; log_warn "Cancelled"; exit 130; }
        return 1
      }
    else
      gum confirm --default=no "$prompt" || {
        [[ $? -eq 130 ]] && { echo ""; log_warn "Cancelled"; exit 130; }
        return 1
      }
    fi
  else
    local yn
    if [[ "$default" == "y" ]]; then
      read -p "$prompt [Y/n]: " yn
      yn="${yn:-y}"
    else
      read -p "$prompt [y/N]: " yn
      yn="${yn:-n}"
    fi
    [[ "$(lowercase "$yn")" == "y" ]]
  fi
}

# Text input prompt
# Usage: result=$(prompt_input "Prompt" "default" "placeholder")
prompt_input() {
  local prompt="$1"
  local default="${2:-}"
  local placeholder="${3:-$default}"

  if has_gum; then
    local result
    if [[ -n "$default" ]]; then
      result=$(run_gum gum input --header "$prompt" --placeholder "$placeholder" --value "$default")
    else
      result=$(run_gum gum input --header "$prompt" --placeholder "$placeholder")
    fi
    echo "${result:-$default}"
  else
    local result
    if [[ -n "$default" ]]; then
      read -p "$prompt (default: $default): " result
    else
      read -p "$prompt: " result
    fi
    echo "${result:-$default}"
  fi
}

# Single choice from options
# Usage: result=$(prompt_choose "Header" "opt1" "opt2" "opt3")
prompt_choose() {
  local header="$1"
  shift
  local options=("$@")

  if has_gum; then
    run_gum gum choose --header "$header" "${options[@]}"
  else
    echo "$header" >&2
    local i=1
    for opt in "${options[@]}"; do
      echo "  $i) $opt" >&2
      ((i++))
    done
    local choice
    read -p "Enter number: " choice
    if [[ "$choice" =~ ^[0-9]+$ ]] && ((choice >= 1 && choice <= ${#options[@]})); then
      echo "${options[$((choice-1))]}"
    else
      echo "${options[0]}"
    fi
  fi
}

# Multi-select from options (returns newline-separated selections)
# Usage: IFS=$'\n' read -r -d '' -a selected < <(prompt_multi "Header" "${opts[@]}"; printf '\0')
prompt_multi() {
  local header="$1"
  shift
  local options=("$@")

  if has_gum; then
    run_gum gum choose --no-limit --header "$header" "${options[@]}"
  else
    echo "$header" >&2
    local i=1
    for opt in "${options[@]}"; do
      echo "  $i) $opt" >&2
      ((i++))
    done
    echo "Enter numbers separated by commas, ranges (1-3), or 'all'" >&2
    local selection
    read -p "Selection: " selection

    if [[ "$(lowercase "$selection")" == "all" ]]; then
      printf '%s\n' "${options[@]}"
    else
      IFS=',' read -ra parts <<< "$selection"
      for part in "${parts[@]}"; do
        part=$(echo "$part" | tr -d ' ')
        if [[ "$part" == *-* ]]; then
          local start="${part%-*}"
          local end="${part#*-}"
          for ((j=start; j<=end; j++)); do
            [[ $j -ge 1 && $j -le ${#options[@]} ]] && echo "${options[$((j-1))]}"
          done
        elif [[ "$part" =~ ^[0-9]+$ ]]; then
          [[ $part -ge 1 && $part -le ${#options[@]} ]] && echo "${options[$((part-1))]}"
        fi
      done
    fi
  fi
}

# Find .hive.yaml starting from current directory, walking up to root
find_config() {
  local dir="$PWD"
  while [[ "$dir" != "/" ]]; do
    if [[ -f "$dir/.hive.yaml" ]]; then
      echo "$dir/.hive.yaml"
      return 0
    fi
    dir="$(dirname "$dir")"
  done
  return 1
}

# Get project directory (parent of .hive.yaml)
get_project_dir() {
  local config="$1"
  dirname "$config"
}

# Get architect backend from config (supports old and new format)
get_architect_backend() {
  local config="$1"
  local arch_backend
  arch_backend=$(yq -r '.architect.backend // ""' "$config")
  if [[ -z "$arch_backend" || "$arch_backend" == "null" ]]; then
    # Fall back to old single backend format
    arch_backend=$(yq -r '.backend // "claude"' "$config")
  fi
  echo "$arch_backend"
}

# Get workers backend from config (supports old and new format)
get_workers_backend() {
  local config="$1"
  local workers_backend
  workers_backend=$(yq -r '.workers.backend // ""' "$config")
  if [[ -z "$workers_backend" || "$workers_backend" == "null" ]]; then
    # Fall back to old single backend format
    workers_backend=$(yq -r '.backend // "claude"' "$config")
  fi
  echo "$workers_backend"
}

# Check dependencies
check_dependencies() {
  local config="${1:-}"
  local missing=()

  command -v yq &>/dev/null || missing+=("yq (brew install yq)")
  command -v tmux &>/dev/null || missing+=("tmux (brew install tmux)")
  command -v tmuxp &>/dev/null || missing+=("tmuxp (pip install tmuxp)")

  if [[ -n "$config" && -f "$config" ]]; then
    local arch_backend workers_backend task_source
    arch_backend=$(get_architect_backend "$config")
    workers_backend=$(get_workers_backend "$config")
    task_source=$(yq -r '.tasks.source // "yaml"' "$config")

    command -v "$arch_backend" &>/dev/null || missing+=("$arch_backend CLI (for architect)")
    if [[ "$workers_backend" != "$arch_backend" ]]; then
      command -v "$workers_backend" &>/dev/null || missing+=("$workers_backend CLI (for workers)")
    fi

    if [[ "$task_source" == "github" ]]; then
      command -v gh &>/dev/null || missing+=("gh (brew install gh)")
      command -v jq &>/dev/null || missing+=("jq (brew install jq)")
    fi
  fi

  if [[ ${#missing[@]} -gt 0 ]]; then
    log_error "Missing dependencies:"
    for dep in "${missing[@]}"; do
      echo "  - $dep"
    done
    return 1
  fi
  return 0
}

# Validate config file
validate_config() {
  local config="$1"

  if [[ ! -f "$config" ]]; then
    log_error "Config file not found: $config"
    return 1
  fi

  # Get backends (supports both old and new format)
  local arch_backend workers_backend session
  arch_backend=$(get_architect_backend "$config")
  workers_backend=$(get_workers_backend "$config")
  session=$(yq -r '.session // ""' "$config")

  # Validate architect backend
  if [[ "$arch_backend" != "codex" && "$arch_backend" != "claude" ]]; then
    log_error "architect backend must be 'codex' or 'claude', got: $arch_backend"
    return 1
  fi

  # Validate workers backend
  if [[ "$workers_backend" != "codex" && "$workers_backend" != "claude" ]]; then
    log_error "workers backend must be 'codex' or 'claude', got: $workers_backend"
    return 1
  fi

  if [[ -z "$session" ]]; then
    log_error "'session' is required in .hive.yaml"
    return 1
  fi

  local num_windows
  num_windows=$(yq -r '.windows | length' "$config")
  if [[ "$num_windows" -eq 0 ]]; then
    log_error "At least one window with workers is required"
    return 1
  fi

  return 0
}

#------------------------------------------------------------------------------
# Worker list and task source functions
#------------------------------------------------------------------------------

# Build array of worker specs: "id|window|pane|lane|dir|branch_local|branch_remote"
# Output: one spec per line
build_worker_list() {
  local config="$1"
  local num_windows
  num_windows=$(yq -r '.windows | length' "$config")

  for ((w=0; w<num_windows; w++)); do
    local window_name
    window_name=$(yq -r ".windows[$w].name" "$config")

    local num_workers
    num_workers=$(yq -r ".windows[$w].workers | length" "$config")

    for ((p=0; p<num_workers; p++)); do
      local id lane dir branch_local branch_remote
      id=$(yq -r ".windows[$w].workers[$p].id" "$config")
      lane=$(yq -r ".windows[$w].workers[$p].lane // \"$id\"" "$config")
      dir=$(yq -r ".windows[$w].workers[$p].dir // \".\"" "$config")
      branch_local=$(yq -r ".windows[$w].workers[$p].branch.local // \"\"" "$config")
      branch_remote=$(yq -r ".windows[$w].workers[$p].branch.remote // \"\"" "$config")

      # tmux panes are 1-indexed
      echo "$id|$window_name|$((p + 1))|$lane|$dir|$branch_local|$branch_remote"
    done
  done
}

# Refresh GitHub items cache
gh_refresh_items() {
  local config="$1"

  local project_id org
  project_id=$(yq -r '.tasks.github_project_id // ""' "$config")
  org=$(yq -r '.tasks.github_org // ""' "$config")

  if [[ -z "$project_id" ]]; then
    log_error "github_project_id required for GitHub task source"
    return 1
  fi

  local status_field lane_field
  status_field=$(yq -r '.tasks.github_status_field_id // ""' "$config")
  lane_field=$(yq -r '.tasks.github_lane_field_id // ""' "$config")

  # GraphQL query to fetch project items
  local query
  query=$(cat <<'EOF'
query($projectId: ID!) {
  node(id: $projectId) {
    ... on ProjectV2 {
      items(first: 100) {
        nodes {
          id
          fieldValues(first: 20) {
            nodes {
              ... on ProjectV2ItemFieldSingleSelectValue {
                name
                field { ... on ProjectV2SingleSelectField { name } }
              }
            }
          }
          content {
            ... on DraftIssue { title }
            ... on Issue { title number }
            ... on PullRequest { title number }
          }
        }
      }
    }
  }
}
EOF
)

  _GH_ITEMS_CACHE=$(gh api graphql -f query="$query" -F projectId="$project_id" 2>/dev/null || echo "{}")
  _GH_ITEMS_CACHE_TIME=$(date +%s)
}

# Get task counts for a lane
# Outputs: "backlog_count in_progress_count" (space-separated)
# Usage: read backlog in_progress <<< "$(get_task_counts "$config" "$lane")"
get_task_counts() {
  local config="$1"
  local lane="$2"
  local backlog_count=0
  local in_progress_count=0

  local task_source
  task_source=$(yq -r '.tasks.source // "yaml"' "$config")

  if [[ "$task_source" == "github" ]]; then
    # Check cache age
    local now
    now=$(date +%s)
    if [[ -z "$_GH_ITEMS_CACHE" ]] || (( now - _GH_ITEMS_CACHE_TIME > 120 )); then
      gh_refresh_items "$config"
    fi

    # Parse cached items for this lane
    # Count items where Lane == lane AND Status == Backlog
    backlog_count=$(echo "$_GH_ITEMS_CACHE" | jq --arg lane "$lane" '
      [.data.node.items.nodes[] |
        select(.fieldValues.nodes[] |
          select(.field.name == "Lane" and .name == $lane)) |
        select(.fieldValues.nodes[] |
          select(.field.name == "Status" and .name == "Backlog"))
      ] | length
    ' 2>/dev/null || echo 0)

    in_progress_count=$(echo "$_GH_ITEMS_CACHE" | jq --arg lane "$lane" '
      [.data.node.items.nodes[] |
        select(.fieldValues.nodes[] |
          select(.field.name == "Lane" and .name == $lane)) |
        select(.fieldValues.nodes[] |
          select(.field.name == "Status" and .name == "In progress"))
      ] | length
    ' 2>/dev/null || echo 0)
  else
    # YAML task source
    local tasks_file project_dir
    project_dir=$(get_project_dir "$config")
    tasks_file=$(yq -r '.tasks.file // ".hive/tasks.yaml"' "$config")
    tasks_file="$project_dir/$tasks_file"

    if [[ -f "$tasks_file" ]]; then
      backlog_count=$(yq -r ".\"$lane\".backlog | length // 0" "$tasks_file" 2>/dev/null || echo 0)
      in_progress_count=$(yq -r ".\"$lane\".in_progress | length // 0" "$tasks_file" 2>/dev/null || echo 0)

      # Handle null values
      [[ "$backlog_count" == "null" ]] && backlog_count=0
      [[ "$in_progress_count" == "null" ]] && in_progress_count=0
    fi
  fi

  echo "$backlog_count $in_progress_count"
}

#------------------------------------------------------------------------------
# tmuxp generation
#------------------------------------------------------------------------------

generate_tmuxp_config() {
  local config="$1"
  local project_dir
  project_dir=$(get_project_dir "$config")

  local arch_backend workers_backend session
  arch_backend=$(get_architect_backend "$config")
  workers_backend=$(get_workers_backend "$config")
  session=$(yq -r '.session' "$config")
  local layout_mode="${HIVE_LAYOUT:-default}"

  local tmuxp_file
  tmuxp_file=$(mktemp).yaml

  # Start YAML
  cat > "$tmuxp_file" <<EOF
session_name: $session
options:
  pane-border-status: top
  pane-border-format: " #{pane_title} "
windows:
EOF

  # Architect command
  local arch_msg="Read .hive/ARCHITECT.md. You are the architect - plan tasks but do NOT edit code. Add tasks to the tasks file for workers to pick up."
  local arch_cmd
  if [[ "$arch_backend" == "codex" ]]; then
    arch_cmd="env -u CODEX_SANDBOX -u CODEX_SANDBOX_NETWORK_DISABLED codex --sandbox danger-full-access --ask-for-approval \"never\" \"$arch_msg\""
  else
    arch_cmd="claude \"$arch_msg\""
  fi
  local arch_cmd_yaml
  arch_cmd_yaml=$(yaml_escape "$arch_cmd")

  # Default mode: architect + all workers in one window (architect on left)
  if [[ "$layout_mode" == "default" ]]; then
    cat >> "$tmuxp_file" <<EOF
  - window_name: hive
    layout: main-vertical
    options:
      main-pane-width: 50%
    panes:
      - shell_command:
          - tmux select-pane -T "architect"
          - cd "$project_dir"
          - "$arch_cmd_yaml"
EOF

    # Add all workers as panes in the same window
    while IFS='|' read -r worker_id window pane worker_lane worker_dir branch_local branch_remote; do
      [[ -z "$worker_id" ]] && continue

      local abs_dir="$project_dir/$worker_dir"

      # Compute relative path from worker dir back to project root's .hive/
      local hive_path=".hive"
      if [[ "$worker_dir" != "." && "$worker_dir" != "./" ]]; then
        # Strip leading ./ and count path segments
        local clean_dir="${worker_dir#./}"
        local depth
        depth=$(echo "$clean_dir" | tr -cd '/' | wc -c)
        depth=$((depth + 1))
        hive_path=""
        for ((i=0; i<depth; i++)); do hive_path="../$hive_path"; done
        hive_path="${hive_path}.hive"
      fi

      # Get startup message
      local initial_msg
      initial_msg=$(yq -r '.messages.startup // ""' "$config")
      if [[ -z "$initial_msg" || "$initial_msg" == "null" ]]; then
        initial_msg="$DEFAULT_STARTUP_MSG"
      fi
      initial_msg="${initial_msg//\{lane\}/$worker_lane}"
      initial_msg="${initial_msg//.hive/$hive_path}"  # Fix path for worktrees
      initial_msg=$(echo "$initial_msg" | tr '\n' ' ' | sed 's/  */ /g')

      # Escape for double-quoted shell string
      local escaped_msg="$initial_msg"
      escaped_msg="${escaped_msg//\\/\\\\}"
      escaped_msg="${escaped_msg//\"/\\\"}"
      escaped_msg="${escaped_msg//\$/\\\$}"
      escaped_msg="${escaped_msg//\`/\\\`}"

      local agent_cmd
      if [[ "$workers_backend" == "codex" ]]; then
        agent_cmd="env -u CODEX_SANDBOX -u CODEX_SANDBOX_NETWORK_DISABLED codex --sandbox danger-full-access --ask-for-approval never \"$escaped_msg\""
      else
        agent_cmd="claude \"$escaped_msg\""
      fi

      local agent_cmd_yaml
      agent_cmd_yaml=$(yaml_escape "$agent_cmd")
      echo "      - shell_command:" >> "$tmuxp_file"
      echo "          - tmux select-pane -T \"$worker_id\"" >> "$tmuxp_file"
      echo "          - cd \"$abs_dir\"" >> "$tmuxp_file"
      printf '          - "%s"\n' "$agent_cmd_yaml" >> "$tmuxp_file"
    done < <(build_worker_list "$config")

  else
    # Default mode: separate windows
    cat >> "$tmuxp_file" <<EOF
  - window_name: architect
    panes:
      - shell_command:
          - tmux select-pane -T "architect"
          - cd "$project_dir"
          - "$arch_cmd_yaml"
EOF
  fi

  # Worker windows (only in custom mode)
  if [[ "$layout_mode" == "custom" ]]; then
    local num_windows
    num_windows=$(yq -r '.windows | length' "$config")

    for ((w=0; w<num_windows; w++)); do
    local window_name layout
    window_name=$(yq -r ".windows[$w].name" "$config")
    layout=$(yq -r ".windows[$w].layout // \"even-horizontal\"" "$config")

    cat >> "$tmuxp_file" <<EOF
  - window_name: $window_name
    layout: $layout
    panes:
EOF

    local num_workers
    num_workers=$(yq -r ".windows[$w].workers | length" "$config")

    for ((p=0; p<num_workers; p++)); do
      local worker_id worker_dir worker_lane
      worker_id=$(yq -r ".windows[$w].workers[$p].id" "$config")
      worker_dir=$(yq -r ".windows[$w].workers[$p].dir // \".\"" "$config")
      worker_lane=$(yq -r ".windows[$w].workers[$p].lane // \"$worker_id\"" "$config")

      # Resolve to absolute path
      local abs_dir="$project_dir/$worker_dir"
      abs_dir=$(cd "$abs_dir" 2>/dev/null && pwd || echo "$abs_dir")

      # Compute relative path from worker dir back to project root's .hive/
      local hive_path=".hive"
      if [[ "$worker_dir" != "." && "$worker_dir" != "./" ]]; then
        # Strip leading ./ and count path segments
        local clean_dir="${worker_dir#./}"
        local depth
        depth=$(echo "$clean_dir" | tr -cd '/' | wc -c)
        depth=$((depth + 1))
        hive_path=""
        for ((i=0; i<depth; i++)); do hive_path="../$hive_path"; done
        hive_path="${hive_path}.hive"
      fi

      # Build agent command - use config message or default
      local agent_cmd initial_msg
      initial_msg=$(yq -r '.messages.startup // ""' "$config")
      if [[ -z "$initial_msg" || "$initial_msg" == "null" ]]; then
        initial_msg="$DEFAULT_STARTUP_MSG"
      fi
      # Replace template variables and convert to single line
      initial_msg="${initial_msg//\{lane\}/$worker_lane}"
      initial_msg="${initial_msg//.hive/$hive_path}"  # Fix path for worktrees
      initial_msg=$(echo "$initial_msg" | tr '\n' ' ' | sed 's/  */ /g')

      # Escape for double-quoted shell string (escape \, ", $, `)
      local escaped_msg="$initial_msg"
      escaped_msg="${escaped_msg//\\/\\\\}"  # backslash
      escaped_msg="${escaped_msg//\"/\\\"}"  # double quote
      escaped_msg="${escaped_msg//\$/\\\$}"  # dollar sign
      escaped_msg="${escaped_msg//\`/\\\`}"  # backtick

      if [[ "$workers_backend" == "codex" ]]; then
        agent_cmd="env -u CODEX_SANDBOX -u CODEX_SANDBOX_NETWORK_DISABLED codex --sandbox danger-full-access --ask-for-approval never \"$escaped_msg\""
      else
        agent_cmd="claude \"$escaped_msg\""
      fi

      # Write YAML with proper quoting to handle special characters (colons, quotes, etc.)
      local agent_cmd_yaml
      agent_cmd_yaml=$(yaml_escape "$agent_cmd")
      echo "      - shell_command:" >> "$tmuxp_file"
      echo "          - tmux select-pane -T \"$worker_id\"" >> "$tmuxp_file"
      echo "          - cd \"$abs_dir\"" >> "$tmuxp_file"
      printf '          - "%s"\n' "$agent_cmd_yaml" >> "$tmuxp_file"
    done
    done
  fi

  # Add watch window
  cat >> "$tmuxp_file" <<EOF
  - window_name: watch
    panes:
      - shell_command:
          - tmux select-pane -T "watcher"
          - cd "$project_dir"
          - hive watch
EOF

  echo "$tmuxp_file"
}

#------------------------------------------------------------------------------
# Commands
#------------------------------------------------------------------------------

cmd_help() {
  cat <<EOF
${SCRIPT_NAME} v${VERSION} - AI Worker Orchestration

USAGE:
    ${SCRIPT_NAME} <command> [options]

COMMANDS:
    init              Create .hive.yaml interactively
    deinit            Remove hive config and generated files
    up                Start worker session
    stop              Stop worker session
    nudge [worker]    Nudge idle workers (or specific one)
    status            Show worker status and task counts
    watch             Run watcher loop (internal, run by 'up')
    role [worker]     Generate .hive/workers/*/WORKER.md files
    doctor            Check and fix common issues
    help              Show this help

EXAMPLES:
    ${SCRIPT_NAME} init                  # Create config interactively
    ${SCRIPT_NAME} up                    # Start all workers
    ${SCRIPT_NAME} status                # Check worker status
    ${SCRIPT_NAME} nudge backend-a       # Nudge specific worker
    ${SCRIPT_NAME} stop                  # Stop all workers

CONFIG:
    Place .hive.yaml in your project root. See 'hive init' to create one.
EOF
}

cmd_up() {
  local config
  config=$(find_config) || { log_error "No .hive.yaml found. Run 'hive init' first."; exit 1; }

  check_dependencies "$config" || exit 1
  validate_config "$config" || exit 1

  local session backend
  session=$(yq -r '.session' "$config")
  backend=$(yq -r '.backend' "$config")

  # Check if session already exists
  if tmux has-session -t "$session" 2>/dev/null; then
    log_warn "Session '$session' already running"
    if prompt_confirm "Kill and restart?"; then
      tmux kill-session -t "$session"
    else
      echo "Use 'hive stop' first, or attach with: tmux attach -t $session"
      exit 1
    fi
  fi

  # Clear codex env vars if needed
  if [[ "$backend" == "codex" ]]; then
    tmux set-environment -gu CODEX_SANDBOX 2>/dev/null || true
    tmux set-environment -gu CODEX_SANDBOX_NETWORK_DISABLED 2>/dev/null || true
  fi

  # Run setup commands if configured
  local project_dir
  project_dir=$(get_project_dir "$config")

  # Ensure hive files are gitignored
  ensure_git_exclude "$project_dir"

  # Choose layout mode
  echo ""
  local layout_mode
  layout_mode=$(prompt_choose "Layout:" "default (all in one window)" "custom (separate windows)")
  [[ "$layout_mode" == *"default"* ]] && layout_mode="default"
  [[ "$layout_mode" == *"custom"* ]] && layout_mode="custom"
  export HIVE_LAYOUT="$layout_mode"

  local num_setup_cmds
  num_setup_cmds=$(yq -r '.setup | length // 0' "$config")

  if [[ "$num_setup_cmds" -gt 0 ]]; then
    log_info "Running setup commands..."
    for ((i=0; i<num_setup_cmds; i++)); do
      local cmd
      cmd=$(yq -r ".setup[$i]" "$config")
      echo "  $ $cmd"
      if ! (cd "$project_dir" && eval "$cmd"); then
        log_error "Setup command failed: $cmd"
        exit 1
      fi
    done
    log_ok "Setup complete"
  fi

  # Generate and load tmuxp config
  log_info "Generating tmux configuration..."
  local tmuxp_file
  tmuxp_file=$(generate_tmuxp_config "$config")

  log_info "Starting session: $session"
  tmuxp load "$tmuxp_file"

  rm -f "$tmuxp_file"

  # Brief delay then initial nudge
  sleep 0.6
  cmd_nudge || true

  log_ok "Session started"
  echo "Attach with: tmux attach -t $session"
}

cmd_stop() {
  local config
  config=$(find_config) || { log_error "No .hive.yaml found"; exit 1; }

  local session
  session=$(yq -r '.session' "$config")

  if tmux has-session -t "$session" 2>/dev/null; then
    log_info "Stopping session: $session"
    tmux kill-session -t "$session"
    log_ok "Session stopped"
  else
    log_warn "Session '$session' not running"
  fi
}

cmd_nudge() {
  local specific_worker="${1:-}"

  local config
  config=$(find_config) || { log_error "No .hive.yaml found"; exit 1; }

  local session task_source
  session=$(yq -r '.session' "$config")
  task_source=$(yq -r '.tasks.source // "yaml"' "$config")

  # Verify session exists
  if ! tmux has-session -t "$session" 2>/dev/null; then
    log_error "Session '$session' not running"
    return 1
  fi

  log_info "Analyzing workers... (source: $task_source)"

  # Pre-fetch GitHub items if needed
  if [[ "$task_source" == "github" ]]; then
    gh_refresh_items "$config" || true
  fi

  local nudged=0

  while IFS='|' read -r id window pane lane dir branch_local branch_remote; do
    [[ -z "$id" ]] && continue

    # Skip if targeting specific worker and this isn't it
    [[ -n "$specific_worker" && "$id" != "$specific_worker" ]] && continue

    # Get task counts
    local backlog_count in_progress_count
    read backlog_count in_progress_count <<< "$(get_task_counts "$config" "$lane")"

    # Only nudge if has backlog and not busy
    if [[ "$backlog_count" -gt 0 && "$in_progress_count" -eq 0 ]]; then
      # Build nudge message - use config message or default
      local msg
      msg=$(yq -r '.messages.nudge // ""' "$config")
      if [[ -z "$msg" || "$msg" == "null" ]]; then
        msg="$DEFAULT_NUDGE_MSG"
      fi
      # Replace template variables and convert to single line
      msg="${msg//\{lane\}/$lane}"
      msg="${msg//\{backlog_count\}/$backlog_count}"
      msg=$(echo "$msg" | tr '\n' ' ' | sed 's/  */ /g')

      # Add branch naming convention if configured
      if [[ -n "$branch_local" && -n "$branch_remote" ]]; then
        msg="$msg BRANCH CONVENTION: Your LOCAL branch names MUST start with '$branch_local/' (e.g. '$branch_local/my-feature'). Push to remote with: git push origin $branch_local/my-feature:$branch_remote/my-feature"
      fi

      # Send to tmux pane
      tmux send-keys -t "$session:$window.$pane" -l "$msg"
      sleep 0.1
      tmux send-keys -t "$session:$window.$pane" Enter

      echo "  -> $id ($window:$pane): $backlog_count task(s)"
      nudged=1
    fi
  done < <(build_worker_list "$config")

  if [[ $nudged -eq 1 ]]; then
    log_ok "Nudged idle workers with pending tasks"
  else
    log_info "No idle workers with pending tasks"
  fi
}

cmd_status() {
  local config
  config=$(find_config) || { log_error "No .hive.yaml found"; exit 1; }

  local session task_source backend
  session=$(yq -r '.session' "$config")
  task_source=$(yq -r '.tasks.source // "yaml"' "$config")
  backend=$(yq -r '.backend' "$config")

  echo ""
  echo "Session: $session"
  echo "Backend: $backend"
  echo "Task Source: $task_source"

  if tmux has-session -t "$session" 2>/dev/null; then
    echo -e "Status: ${GREEN}RUNNING${NC}"
  else
    echo -e "Status: ${RED}STOPPED${NC}"
  fi
  echo ""

  # Pre-fetch GitHub items if needed
  if [[ "$task_source" == "github" ]]; then
    gh_refresh_items "$config" || true
  fi

  # Worker table header
  printf "%-20s %-15s %-10s %-12s\n" "WORKER" "LANE" "BACKLOG" "IN_PROGRESS"
  printf "%-20s %-15s %-10s %-12s\n" "------" "----" "-------" "-----------"

  while IFS='|' read -r id window pane lane dir branch_local branch_remote; do
    [[ -z "$id" ]] && continue

    local backlog_count in_progress_count
    read backlog_count in_progress_count <<< "$(get_task_counts "$config" "$lane")"

    printf "%-20s %-15s %-10s %-12s\n" "$id" "$lane" "$backlog_count" "$in_progress_count"
  done < <(build_worker_list "$config")

  echo ""
}

cmd_watch() {
  local config
  config=$(find_config) || { log_error "No .hive.yaml found"; exit 1; }

  local session task_source
  session=$(yq -r '.session' "$config")
  task_source=$(yq -r '.tasks.source // "yaml"' "$config")

  log_info "Hive watcher starting..."
  log_info "Task source: $task_source"

  # Wait for all windows to be ready
  log_info "Waiting for windows..."
  local retries=0
  while true; do
    local all_ready=1
    local num_windows
    num_windows=$(yq -r '.windows | length' "$config")

    for ((w=0; w<num_windows; w++)); do
      local window_name
      window_name=$(yq -r ".windows[$w].name" "$config")

      if ! tmux list-windows -t "$session" -F "#{window_name}" 2>/dev/null | grep -qx "$window_name"; then
        all_ready=0
        break
      fi
    done

    [[ $all_ready -eq 1 ]] && break

    retries=$((retries + 1))
    if ((retries > MAX_RETRIES)); then
      log_error "Timeout waiting for windows"
      exit 1
    fi

    sleep "$RETRY_INTERVAL"
  done
  log_ok "All windows ready"

  # Initial nudge
  cmd_nudge || true

  # Watch loop
  local last_nudge=0

  if [[ "$task_source" == "github" ]]; then
    log_info "Polling GitHub every ${GITHUB_POLL_INTERVAL}s"
    echo "Press Ctrl+C to stop"
    echo ""

    while true; do
      sleep "$GITHUB_POLL_INTERVAL"
      echo "[$(date +%H:%M:%S)] Polling GitHub..."
      cmd_nudge 2>/dev/null || true
    done
  else
    local tasks_file project_dir
    project_dir=$(get_project_dir "$config")
    tasks_file=$(yq -r '.tasks.file // ".hive/tasks.yaml"' "$config")
    tasks_file="$project_dir/$tasks_file"

    if command -v fswatch &>/dev/null; then
      log_info "Watching: $tasks_file (fswatch)"
      echo "Press Ctrl+C to stop"
      echo ""

      fswatch -o "$tasks_file" 2>/dev/null | while read -r _; do
        local now
        now=$(date +%s)
        local elapsed=$((now - last_nudge))

        if (( elapsed < DEBOUNCE_SECONDS )); then
          echo "[$(date +%H:%M:%S)] Change detected, debouncing..."
          continue
        fi

        echo "[$(date +%H:%M:%S)] File changed, waiting to settle..."
        sleep "$SETTLE_SECONDS"

        last_nudge=$(date +%s)
        cmd_nudge 2>/dev/null || true
      done
    else
      log_info "Watching: $tasks_file (polling)"
      log_warn "Install fswatch for better performance: brew install fswatch"
      echo "Press Ctrl+C to stop"
      echo ""

      local last_mtime
      last_mtime=$(stat -f %m "$tasks_file" 2>/dev/null || stat -c %Y "$tasks_file" 2>/dev/null || echo 0)

      while true; do
        sleep 1
        local mtime
        mtime=$(stat -f %m "$tasks_file" 2>/dev/null || stat -c %Y "$tasks_file" 2>/dev/null || echo 0)

        if [[ "$mtime" != "$last_mtime" ]]; then
          last_mtime="$mtime"

          local now
          now=$(date +%s)
          local elapsed=$((now - last_nudge))

          if (( elapsed < DEBOUNCE_SECONDS )); then
            echo "[$(date +%H:%M:%S)] Change detected, debouncing..."
            continue
          fi

          echo "[$(date +%H:%M:%S)] File changed, waiting to settle..."
          sleep "$SETTLE_SECONDS"

          last_nudge=$(date +%s)
          cmd_nudge 2>/dev/null || true
        fi
      done
    fi
  fi
}

cmd_init() {
  if has_gum; then
    gum style --border double --padding "0 2" --border-foreground 212 "Hive Configuration Wizard"
  else
    echo ""
    echo "Hive Configuration Wizard"
    echo "========================="
  fi
  echo ""
  echo "This wizard will guide you through setting up hive."
  echo "Nothing will be created until you confirm at the end."
  echo ""

  # Check if config already exists
  if [[ -f ".hive.yaml" ]]; then
    log_warn ".hive.yaml already exists"
    prompt_confirm "Overwrite existing config?" || exit 0
  fi

  # Step 1: Backends (architect and workers can differ)
  echo "┌─────────────────────────────────────────────────────────┐"
  echo "│  ARCHITECT vs WORKERS                                   │"
  echo "├─────────────────────────────────────────────────────────┤"
  echo "│  ARCHITECT                                              │"
  echo "│    • Plans and coordinates work                         │"
  echo "│    • Researches codebase before proposing tasks         │"
  echo "│    • Adds tasks to the backlog for workers              │"
  echo "│    • Does NOT edit code or make commits                 │"
  echo "│    • Claude recommended for stronger reasoning          │"
  echo "│                                                         │"
  echo "│  WORKERS                                                │"
  echo "│    • Execute tasks from their lane's backlog            │"
  echo "│    • Write code and push PRs                            │"
  echo "│    • Handle one task at a time                          │"
  echo "└─────────────────────────────────────────────────────────┘"
  echo ""

  local arch_backend
  arch_backend=$(prompt_choose "Architect backend:" "claude (recommended)" "codex")
  # Strip the description suffix
  [[ "$arch_backend" == *"claude"* ]] && arch_backend="claude"
  [[ "$arch_backend" == *"codex"* ]] && arch_backend="codex"

  local workers_backend
  workers_backend=$(prompt_choose "Workers backend:" "claude" "codex")

  # Step 2: Session name
  local default_session
  default_session=$(basename "$PWD" | tr '[:upper:]' '[:lower:]' | tr ' _' '-')
  local session
  session=$(prompt_input "Session name" "$default_session")

  # Step 3: Task source
  local task_source
  task_source=$(prompt_choose "Select task source:" "yaml" "github")

  local tasks_file="" github_project="" github_org="" github_project_id=""
  local github_status_field="" github_lane_field=""

  if [[ "$task_source" == "github" ]]; then
    github_org=$(prompt_input "GitHub org name" "" "my-org")
    github_project=$(prompt_input "GitHub Project number" "" "1")
    github_project_id=$(prompt_input "GitHub Project ID" "" "PVT_...")
    github_status_field=$(prompt_input "Status field ID" "" "PVTSSF_...")
    github_lane_field=$(prompt_input "Lane field ID" "" "PVTSSF_...")
  else
    tasks_file=$(prompt_input "Tasks file path" ".hive/tasks.yaml")
  fi

  # Step 4: Scan and select directories
  echo ""
  log_info "Scanning for subdirectories..."

  local -a available_dirs=()
  local -a display_names=()

  for d in */; do
    [[ ! -d "$d" ]] && continue
    local name="${d%/}"

    # Skip common non-worker directories
    [[ "$name" == "node_modules" || "$name" == ".git" || "$name" == "vendor" || "$name" == "dist" || "$name" == "build" ]] && continue

    available_dirs+=("$name")
    if [[ -d "$d/.git" ]]; then
      display_names+=("$name [git]")
    else
      display_names+=("$name")
    fi
  done

  local -a workers=()
  local -a worker_ids=()
  local -a pending_worktrees=()

  if [[ ${#available_dirs[@]} -eq 0 ]]; then
    log_warn "No subdirectories found."
  else
    # Multi-select directories
    echo ""
    local -a selected_display=()
    IFS=$'\n' read -r -d '' -a selected_display < <(prompt_multi "Select directories to include as workers:" "${display_names[@]}"; printf '\0') || true

    # Configure each selected directory
    for sel in "${selected_display[@]}"; do
      [[ -z "$sel" ]] && continue

      # Check if this is a git repo (display name ends with " [git]")
      local is_git=0
      local name="$sel"
      if [[ "$sel" == *" [git]" ]]; then
        is_git=1
        name="${sel% \[git\]}"
      fi

      echo ""
      if has_gum; then
        gum style --foreground 212 "Configuring: $name"
      else
        echo "--- Configuring: $name ---"
      fi

      # If it's a git repo, offer to create worktrees
      if [[ "$is_git" == "1" ]]; then
        if prompt_confirm "Create git worktrees for parallel workers?"; then
          local num_workers
          num_workers=$(prompt_input "How many workers?" "3")

          echo ""
          echo "Each worker needs a purpose (e.g., 'api', 'auth', 'frontend')."
          echo "This creates:"
          echo "  - Worktree folder: ${name}-<purpose>"
          echo "  - Branch pattern:  ${name}-<purpose>/<purpose>/<feature>"
          echo ""

          # Collect purposes first, then create worktree requests
          local -a purposes=()
          for ((i=0; i<num_workers; i++)); do
            local purpose
            purpose=$(prompt_input "Purpose for worker $((i+1))" "")
            [[ -z "$purpose" ]] && continue
            purposes+=("$purpose")
          done

          # Store worktree request for later creation (source_dir|purpose1,purpose2,...)
          local purposes_str
          purposes_str=$(IFS=,; echo "${purposes[*]}")
          pending_worktrees+=("$name|$purposes_str")

          for purpose in "${purposes[@]}"; do
            local wt_name="${name}-${purpose}"

            # Auto-generate branch prefixes from purpose
            local branch_local="${wt_name}/${purpose}"
            local branch_remote="${purpose}"

            workers+=("$wt_name|$purpose|$branch_local|$branch_remote")
            worker_ids+=("$wt_name")
          done

          continue  # Skip adding the original repo as a worker
        fi
      fi

      # Regular (non-worktree) worker
      local lane
      lane=$(prompt_input "Lane name" "$name")

      workers+=("$name|$lane||")
      worker_ids+=("$name")
    done
  fi

  if [[ ${#workers[@]} -eq 0 ]]; then
    log_warn "No workers added. Creating minimal config."
  fi

  # Step 5: Group workers into windows (for custom layout)
  echo ""
  local -a windows=()

  if [[ ${#workers[@]} -gt 0 ]]; then
    echo "┌─────────────────────────────────────────────────────────┐"
    echo "│  WINDOW GROUPING (for custom layout)                    │"
    echo "├─────────────────────────────────────────────────────────┤"
    echo "│  At 'hive up' you can choose:                           │"
    echo "│    default - All in one window (architect top, workers  │"
    echo "│              tiled below)                               │"
    echo "│    custom  - Separate windows with your groupings       │"
    echo "└─────────────────────────────────────────────────────────┘"
    echo ""

    if prompt_confirm "Group all workers into one window (for custom layout)?" "y"; then
      local window_name
      window_name=$(prompt_input "Window name" "workers")
      windows+=("$window_name|${worker_ids[*]}")
    else
      echo ""
      echo "Create windows by selecting workers, then naming the group."
      echo "Workers can only belong to one window."
      echo ""

      # Track remaining workers
      local -a remaining_workers=("${worker_ids[@]}")

      while [[ ${#remaining_workers[@]} -gt 0 ]]; do
        echo "Remaining workers: ${remaining_workers[*]}"
        echo ""

        # Let user select workers first
        local -a win_worker_selection=()
        IFS=$'\n' read -r -d '' -a win_worker_selection < <(prompt_multi "Select workers for this window:" "${remaining_workers[@]}"; printf '\0') || true

        [[ ${#win_worker_selection[@]} -eq 0 ]] && break

        # Then name the window based on selection
        local default_win_name="${win_worker_selection[0]}"
        [[ ${#win_worker_selection[@]} -gt 1 ]] && default_win_name="workers-$((${#windows[@]} + 1))"

        local win_name
        win_name=$(prompt_input "Name for this window" "$default_win_name")

        local win_workers_str="${win_worker_selection[*]}"
        windows+=("$win_name|$win_workers_str")

        # Remove selected workers from remaining
        local new_remaining=""
        for w in "${remaining_workers[@]}"; do
          local found=0
          for sel in "${win_worker_selection[@]}"; do
            [[ "$w" == "$sel" ]] && found=1 && break
          done
          [[ $found -eq 0 ]] && new_remaining="$new_remaining $w"
        done
        # Convert back to array (safe for empty - just trims whitespace)
        read -ra remaining_workers <<< "$new_remaining"

        [[ ${#remaining_workers[@]} -eq 0 ]] && break
        echo ""
        if ! prompt_confirm "Customize another window? (No = group remaining into one window)"; then
          # Group remaining workers into one window
          if [[ ${#remaining_workers[@]} -gt 0 ]]; then
            local rest_name
            rest_name=$(prompt_input "Name for remaining workers window" "other")
            windows+=("$rest_name|${remaining_workers[*]}")
          fi
          break
        fi
      done
    fi
  fi

  # Step 6: Summary and confirmation
  echo ""
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo "Summary"
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo ""
  echo "Architect:    $arch_backend"
  echo "Workers:      $workers_backend"
  echo "Session:      $session"
  echo "Task source:  $task_source"
  echo ""
  echo "Worker count: ${#worker_ids[@]}"
  for wid in "${worker_ids[@]}"; do
    echo "  - $wid"
  done
  echo ""
  echo "Windows:      ${#windows[@]} (+ watch window)"
  for win_spec in "${windows[@]}"; do
    IFS='|' read -r wn ww <<< "$win_spec"
    echo "  - $wn: $ww"
  done
  if [[ ${#pending_worktrees[@]} -gt 0 ]]; then
    echo ""
    echo "Worktrees to create:"
    for wt_request in "${pending_worktrees[@]}"; do
      IFS='|' read -r src purposes_str <<< "$wt_request"
      echo "  - From $src/: ${purposes_str//,/, }"
    done
  fi
  echo ""
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo ""

  if ! prompt_confirm "Create configuration and worktrees?" "y"; then
    log_warn "Cancelled. Nothing was created."
    exit 0
  fi

  # Step 7: Generate config
  echo ""
  log_info "Generating .hive.yaml..."

  cat > .hive.yaml <<EOF
architect:
  backend: $arch_backend

workers:
  backend: $workers_backend

session: $session

tasks:
  source: $task_source
EOF

  if [[ "$task_source" == "github" ]]; then
    cat >> .hive.yaml <<EOF
  github_org: $github_org
  github_project: $github_project
  github_project_id: $github_project_id
  github_status_field_id: $github_status_field
  github_lane_field_id: $github_lane_field
EOF
  else
    cat >> .hive.yaml <<EOF
  file: $tasks_file
EOF
  fi

  if [[ ${#windows[@]} -gt 0 ]]; then
    cat >> .hive.yaml <<EOF

windows:
EOF

    for win_spec in "${windows[@]}"; do
      IFS='|' read -r win_name win_worker_list <<< "$win_spec"

      cat >> .hive.yaml <<EOF
  - name: $win_name
    layout: even-horizontal
    workers:
EOF

      # Find workers for this window
      for worker_spec in "${workers[@]}"; do
        IFS='|' read -r w_id w_lane w_bl w_br <<< "$worker_spec"

        # Check if this worker is in this window
        if [[ " $win_worker_list " == *" $w_id "* ]] || [[ "$win_worker_list" == *"$w_id"* ]]; then
          cat >> .hive.yaml <<EOF
      - id: $w_id
        dir: ./$w_id
        lane: $w_lane
EOF
          if [[ -n "$w_bl" || -n "$w_br" ]]; then
            cat >> .hive.yaml <<EOF
        branch:
          local: "$w_bl"
          remote: "$w_br"
EOF
          fi
        fi
      done
    done
  else
    # Create placeholder window
    cat >> .hive.yaml <<EOF

windows:
  - name: workers
    layout: even-horizontal
    workers:
      - id: example
        dir: .
        lane: default
EOF
  fi

  # Add messages section with defaults
  cat >> .hive.yaml <<'EOF'

# Messages sent to workers (customize these for your workflow)
# Available variables: {lane}, {backlog_count}
messages:
  startup: |
    Read .hive/workers/{lane}/WORKER.md if it exists. You are assigned to lane '{lane}'.
    Check your task backlog. If backlog is EMPTY, report 'No tasks in backlog for {lane}'
    and STOP - do NOT explore or look for other work.
    If tasks exist, claim ONE task and work on it.
    When finished, create a git branch, commit, push, and create a Pull Request.
  nudge: |
    You have {backlog_count} task(s) in your backlog for lane '{lane}'.
    If you have uncommitted changes from a previous task, create a PR first.
    Claim ONE task and work on it.
    When done, create a branch, commit, push, and create a Pull Request.
EOF

  # Create any pending worktrees now that config is complete
  if [[ ${#pending_worktrees[@]} -gt 0 ]]; then
    echo ""
    log_info "Creating git worktrees..."

    for wt_request in "${pending_worktrees[@]}"; do
      IFS='|' read -r source_dir purposes_str <<< "$wt_request"
      IFS=',' read -ra purposes <<< "$purposes_str"

      for purpose in "${purposes[@]}"; do
        local wt_name="${source_dir}-${purpose}"
        local wt_path="$PWD/$wt_name"

        if [[ ! -d "$wt_path" ]]; then
          # Create worktree with a new branch
          local branch_name="worker-${purpose}"
          if (cd "$source_dir" && git worktree add "$wt_path" -b "$branch_name" 2>/dev/null) || \
             (cd "$source_dir" && git worktree add "$wt_path" HEAD 2>/dev/null); then
            echo "  Created worktree: $wt_name"
          else
            log_warn "  Failed to create worktree: $wt_name"
          fi
        else
          echo "  Worktree exists: $wt_name"
        fi
      done
    done
  fi

  log_ok "Created .hive.yaml"

  # Create tasks.yaml if using yaml source
  if [[ "$task_source" == "yaml" ]]; then
    bootstrap_tasks_file ".hive.yaml"
  fi

  # Set up .git/info/exclude so hive files aren't tracked
  ensure_git_exclude "$PWD"
  log_ok "Added hive files to .git/info/exclude"

  echo ""

  # Offer to generate role files
  if [[ ${#workers[@]} -gt 0 ]]; then
    if prompt_confirm "Generate .hive/workers/*/WORKER.md files?" "y"; then
      cmd_role
    fi
  fi

  echo ""
  if has_gum; then
    gum style --foreground 10 "Next steps:"
    echo "  1. Review .hive.yaml"
    echo "  2. Run 'hive up' to start workers"
  else
    echo "Next steps:"
    echo "  1. Review .hive.yaml"
    echo "  2. Run 'hive up' to start workers"
  fi
}

cmd_deinit() {
  local config
  config=$(find_config) || { log_error "No .hive.yaml found. Nothing to remove."; exit 1; }

  local project_dir session
  project_dir=$(get_project_dir "$config")
  session=$(yq -r '.session // ""' "$config")

  echo ""
  log_warn "This will remove hive configuration and generated files."
  echo ""

  # Stop session if running
  if [[ -n "$session" ]] && tmux has-session -t "$session" 2>/dev/null; then
    log_warn "Session '$session' is running"
    if prompt_confirm "Stop the running session?"; then
      tmux kill-session -t "$session"
      log_ok "Session stopped"
    fi
  fi

  # Collect what we'll remove
  local -a worktrees_to_remove=()

  # Find worktrees
  while IFS='|' read -r id window pane lane dir branch_local branch_remote; do
    [[ -z "$id" ]] && continue
    local abs_dir="$project_dir/$dir"
    # Check if this is a git worktree (has .git file, not directory)
    if [[ -f "$abs_dir/.git" ]]; then
      worktrees_to_remove+=("$abs_dir")
    fi
  done < <(build_worker_list "$config")

  # Show what will be removed
  echo "Will remove:"
  echo "  - $config"
  [[ -d "$project_dir/.hive" ]] && echo "  - $project_dir/.hive/"
  echo ""

  if [[ ${#worktrees_to_remove[@]} -gt 0 ]]; then
    echo "Detected git worktrees:"
    for wt in "${worktrees_to_remove[@]}"; do
      echo "  - $wt"
    done
    echo ""
  fi

  if ! prompt_confirm "Remove these?"; then
    log_warn "Cancelled"
    exit 0
  fi

  # Remove .hive directory
  if [[ -d "$project_dir/.hive" ]]; then
    rm -rf "$project_dir/.hive" && echo "  Removed: $project_dir/.hive/"
  fi

  # Handle worktrees
  if [[ ${#worktrees_to_remove[@]} -gt 0 ]]; then
    echo ""
    if prompt_confirm "Also remove git worktrees? (This will delete the directories)"; then
      for wt in "${worktrees_to_remove[@]}"; do
        # Find the main repo for this worktree
        local git_dir
        git_dir=$(cat "$wt/.git" 2>/dev/null | sed 's/gitdir: //')
        if [[ -n "$git_dir" ]]; then
          # Extract main repo path (worktree gitdir is usually .git/worktrees/<name>)
          local main_repo
          main_repo=$(dirname "$(dirname "$(dirname "$git_dir")")")
          if [[ -d "$main_repo/.git" ]]; then
            (cd "$main_repo" && git worktree remove "$wt" --force 2>/dev/null) && echo "  Removed worktree: $wt" || log_warn "  Failed to remove worktree: $wt"
          else
            rm -rf "$wt" && echo "  Removed directory: $wt"
          fi
        else
          rm -rf "$wt" && echo "  Removed directory: $wt"
        fi
      done
    fi
  fi

  # Remove config last
  rm -f "$config" && echo "  Removed: $config"

  echo ""
  log_ok "Hive configuration removed"
}

cmd_role() {
  local specific_worker="${1:-}"

  local config
  config=$(find_config) || { log_error "No .hive.yaml found"; exit 1; }

  local project_dir task_source
  project_dir=$(get_project_dir "$config")
  task_source=$(yq -r '.tasks.source // "yaml"' "$config")

  while IFS='|' read -r id window pane lane dir branch_local branch_remote; do
    [[ -z "$id" ]] && continue

    # Skip if targeting specific worker
    [[ -n "$specific_worker" && "$id" != "$specific_worker" ]] && continue

    local abs_dir="$project_dir/$dir"
    local role_dir="$project_dir/.hive/workers/$id"
    local role_file="$role_dir/WORKER.md"

    # Check if custom content exists
    local custom_content=""
    if [[ -f "$role_file" ]]; then
      # Extract content after "## Project-Specific Instructions"
      custom_content=$(sed -n '/^## Project-Specific Instructions/,$p' "$role_file" | tail -n +2)
    fi

    mkdir -p "$role_dir"
    log_info "Generating $role_file"

    cat > "$role_file" <<EOF
# Worker Role: $id

You are a background worker assigned to lane **$lane**.

## General Behavior
1. Check your task backlog and claim ONE task at a time
2. Implement the task completely
3. **CRITICAL: You MUST create a Pull Request before stopping or claiming another task**
4. If you have uncommitted changes from a previous task, create a PR for them FIRST
5. Do NOT stop working until you see a PR URL displayed

## When Backlog is Empty
If your lane's backlog is empty, **STOP IMMEDIATELY**.
- Report "No tasks in backlog for lane $lane"
- Do NOT look for other work
- Do NOT explore the codebase
- Do NOT make suggestions
- Simply wait for the architect to add tasks

## Creating a Pull Request (REQUIRED)
After completing a task, you MUST follow these steps:
1. Create a branch: \`git checkout -b <branch-name>\`
2. Stage changes: \`git add -A\`
3. Commit: \`git commit -m "description of changes"\`
4. Push: \`git push -u origin <branch-name>\`
5. Create PR: \`gh pr create --fill\` or \`gh pr create --title "..." --body "..."\`
6. **Verify the PR URL is displayed before stopping**

EOF

    # Add branch naming if configured
    if [[ -n "$branch_local" && -n "$branch_remote" ]]; then
      cat >> "$role_file" <<EOF
## Branch Naming Convention
- Create local branches with prefix: \`$branch_local/\`
- Example: \`$branch_local/my-feature\`
- Push command: \`git push origin $branch_local/my-feature:$branch_remote/my-feature\`

EOF
    fi

    # Add task source instructions
    if [[ "$task_source" == "github" ]]; then
      local github_project
      github_project=$(yq -r '.tasks.github_project // ""' "$config")
      cat >> "$role_file" <<EOF
## Task Source
Tasks are managed in GitHub Project #$github_project.
- View your lane's backlog in the project board
- Move tasks to "In Progress" when you start
- Move tasks to "Done" when PR is merged

EOF
    else
      local tasks_file
      tasks_file=$(yq -r '.tasks.file // ".hive/tasks.yaml"' "$config")

      # Compute relative path from worker dir to tasks file
      # Count depth of worker dir and prepend ../
      local worker_rel_tasks="$tasks_file"
      if [[ "$dir" != "." && "$dir" != "./" ]]; then
        local depth
        depth=$(echo "$dir" | tr -cd '/' | wc -c | tr -d ' ')
        # Add 1 if dir doesn't end with / but has content
        [[ "$dir" != */ && -n "$dir" ]] && depth=$((depth + 1))
        local prefix=""
        for ((i=0; i<depth; i++)); do
          prefix="../$prefix"
        done
        # Strip leading ./ from tasks_file if present
        worker_rel_tasks="${prefix}${tasks_file#./}"
      fi

      cat >> "$role_file" <<EOF
## Task Source
Tasks are managed in \`$worker_rel_tasks\` (relative to your working directory).
- Your lane: \`$lane\`
- Check the \`backlog\` section for pending tasks
- Move tasks to \`in_progress\` when you start
- Move tasks to \`done\` when complete

EOF
    fi

    # Add worker_instructions from config if present
    local config_instructions
    config_instructions=$(yq -r '.worker_instructions // ""' "$config")
    if [[ -n "$config_instructions" && "$config_instructions" != "null" ]]; then
      cat >> "$role_file" <<EOF
## Additional Instructions (from .hive.yaml)
$config_instructions

EOF
    fi

    # Add custom content section
    cat >> "$role_file" <<EOF
---
## Project-Specific Instructions
<!-- Add your custom instructions below this line -->
EOF

    if [[ -n "$custom_content" ]]; then
      echo "$custom_content" >> "$role_file"
    else
      echo "" >> "$role_file"
    fi

  done < <(build_worker_list "$config")

  # Generate .hive/ARCHITECT.md
  generate_architect_role "$config"

  log_ok "Role files generated"
}

# Generate .hive/ARCHITECT.md
generate_architect_role() {
  local config="$1"
  local project_dir task_source tasks_file
  project_dir=$(get_project_dir "$config")
  task_source=$(yq -r '.tasks.source // "yaml"' "$config")
  tasks_file=$(yq -r '.tasks.file // ".hive/tasks.yaml"' "$config")

  mkdir -p "$project_dir/.hive"
  local role_file="$project_dir/.hive/ARCHITECT.md"

  # Collect worker lanes for reference
  local lanes=""
  while IFS='|' read -r id window pane lane dir branch_local branch_remote; do
    [[ -z "$id" ]] && continue
    lanes="$lanes\n- **$id** → lane: \`$lane\`"
  done < <(build_worker_list "$config")

  log_info "Generating $role_file"

  cat > "$role_file" <<EOF
# Architect Role

You are the **architect** - you plan work but do NOT write code.

## Core Principles

1. **Planning only** - You do NOT edit code or make commits
2. **Research first** - Explore the codebase before proposing tasks
3. **Get confirmation** - List task titles and wait for user approval before adding
4. **One task at a time per worker** - Don't overload the backlog

## Your Responsibilities

- Convert user intent into well-scoped tasks with clear acceptance criteria
- Place tasks in the correct lane for the appropriate worker
- Ask clarifying questions instead of guessing
- Monitor worker progress and unblock them when needed

## Available Workers
$(echo -e "$lanes")

## Task Structure

Each task should include:
- **id**: Unique identifier (kebab-case)
- **description**: What needs to be implemented
- **acceptance**: List of criteria for completion

EOF

  if [[ "$task_source" == "github" ]]; then
    local github_project
    github_project=$(yq -r '.tasks.github_project // ""' "$config")
    cat >> "$role_file" <<EOF
## Task Management

Tasks are managed in **GitHub Project #$github_project**.

Use the GitHub Project board to:
- Add new tasks to the appropriate lane's backlog
- Monitor task status (Backlog → In Progress → Done)
- Review completed work

EOF
  else
    cat >> "$role_file" <<EOF
## Task Management

Tasks are managed in \`$tasks_file\`.

### Adding a Task

\`\`\`yaml
<lane-name>:
  backlog:
    - id: my-task-id
      description: What needs to be done
      acceptance:
        - First acceptance criterion
        - Second acceptance criterion
\`\`\`

### Task Lifecycle

1. **backlog** - Tasks waiting to be claimed
2. **in_progress** - Worker is actively working (max 1 per worker)
3. **done** - Completed with summary

EOF
  fi

  cat >> "$role_file" <<EOF
---
## Project-Specific Instructions
<!-- Add your custom instructions below this line -->

EOF
}

# Bootstrap tasks.yaml with all lanes
bootstrap_tasks_file() {
  local config="$1"
  local project_dir task_source tasks_file
  project_dir=$(get_project_dir "$config")
  task_source=$(yq -r '.tasks.source // "yaml"' "$config")

  # Only for yaml task source
  [[ "$task_source" != "yaml" ]] && return 0

  tasks_file=$(yq -r '.tasks.file // ".hive/tasks.yaml"' "$config")
  local full_path="$project_dir/$tasks_file"

  # Don't overwrite existing file
  if [[ -f "$full_path" ]]; then
    return 0
  fi

  log_info "Creating $tasks_file..."

  # Collect all unique lanes from workers
  local lanes=""
  while IFS='|' read -r id window pane lane dir branch_local branch_remote; do
    [[ -z "$id" ]] && continue
    # Add lane if not already in list
    if [[ ! " $lanes " == *" $lane "* ]]; then
      lanes="$lanes $lane"
    fi
  done < <(build_worker_list "$config")

  # Generate tasks file
  mkdir -p "$(dirname "$full_path")"
  cat > "$full_path" <<'EOF'
# Hive Task Queue
# The architect adds tasks here, workers claim and complete them

worker_protocol:
  claim:
    - Check your lane's backlog for tasks
    - Move ONE task to in_progress
    - Set claimed_by and claimed_at
    - Start implementing
  done:
    - Move task to done
    - Add summary and files_changed
  blocked:
    - Add question field and wait

rules:
  - Architect plans and adds tasks (does NOT edit code)
  - Workers claim ONE task at a time
  - Every task needs: id, description, acceptance criteria
  - Push PR before claiming next task
  - If blocked, add question and wait

global_backlog: []

EOF

  # Add each lane
  for lane in $lanes; do
    cat >> "$full_path" <<EOF
$lane:
  backlog: []
  in_progress: []
  done: []

EOF
  done

  log_ok "Created $tasks_file with lanes:$lanes"
}

cmd_doctor() {
  local config
  config=$(find_config) || { log_error "No .hive.yaml found. Run 'hive init' first."; exit 1; }

  local project_dir
  project_dir=$(get_project_dir "$config")

  echo ""
  log_info "Running hive doctor..."
  echo ""

  local issues_found=0
  local issues_fixed=0

  # Check 1: tasks.yaml exists (for yaml source)
  local task_source tasks_file
  task_source=$(yq -r '.tasks.source // "yaml"' "$config")

  if [[ "$task_source" == "yaml" ]]; then
    tasks_file=$(yq -r '.tasks.file // ".hive/tasks.yaml"' "$config")
    local full_tasks_path="$project_dir/$tasks_file"

    if [[ ! -f "$full_tasks_path" ]]; then
      log_warn "Missing: $tasks_file"
      issues_found=$((issues_found + 1))

      if prompt_confirm "Create $tasks_file with all lanes?"; then
        bootstrap_tasks_file "$config"
        issues_fixed=$((issues_fixed + 1))
      fi
    else
      log_ok "Found: $tasks_file"
    fi
  fi

  # Check 2: .hive/ARCHITECT.md exists
  if [[ ! -f "$project_dir/.hive/ARCHITECT.md" ]]; then
    log_warn "Missing: .hive/ARCHITECT.md"
    issues_found=$((issues_found + 1))

    if prompt_confirm "Generate .hive/ARCHITECT.md?"; then
      generate_architect_role "$config"
      log_ok "Generated .hive/ARCHITECT.md"
      issues_fixed=$((issues_fixed + 1))
    fi
  else
    log_ok "Found: .hive/ARCHITECT.md"
  fi

  # Check 3: .hive/workers/<worker>/WORKER.md for each worker
  local -a missing_workers=()
  while IFS='|' read -r id window pane lane dir branch_local branch_remote; do
    [[ -z "$id" ]] && continue
    local role_file="$project_dir/.hive/workers/$id/WORKER.md"

    if [[ ! -f "$role_file" ]]; then
      log_warn "Missing: .hive/workers/$id/WORKER.md"
      missing_workers+=("$id")
      issues_found=$((issues_found + 1))
    else
      log_ok "Found: .hive/workers/$id/WORKER.md"
    fi
  done < <(build_worker_list "$config")

  # Offer to regenerate role files if any are missing
  if [[ ${#missing_workers[@]} -gt 0 ]]; then
    echo ""
    if prompt_confirm "Generate missing worker role files?"; then
      cmd_role
      issues_fixed=$((issues_fixed + ${#missing_workers[@]}))
    fi
  fi

  # Check 4: .git/info/exclude has .hive/
  echo ""
  log_info "Checking .git/info/exclude..."

  if [[ -e "$project_dir/.git" ]]; then
    local exclude_file="$project_dir/.git/info/exclude"

    # For worktrees, resolve to main repo
    if [[ -f "$project_dir/.git" ]]; then
      local git_dir
      git_dir=$(cat "$project_dir/.git" | sed 's/^gitdir: //')
      exclude_file="$(dirname "$(dirname "$git_dir")")/info/exclude"
    fi

    if ! grep -qxF ".hive/" "$exclude_file" 2>/dev/null; then
      log_warn "Missing .hive/ in .git/info/exclude"
      issues_found=$((issues_found + 1))

      if prompt_confirm "Add .hive/ to .git/info/exclude? (local only, not committed)"; then
        ensure_git_exclude "$project_dir"
        issues_fixed=$((issues_fixed + 1))
        log_ok "Updated .git/info/exclude"
      fi
    else
      log_ok ".git/info/exclude has .hive/"
    fi
  else
    log_ok "Not a git repo, skipping exclude check"
  fi

  # Check 5: messages section in config
  echo ""
  log_info "Checking config for messages section..."
  local has_messages
  has_messages=$(yq -r '.messages // ""' "$config")
  if [[ -z "$has_messages" || "$has_messages" == "null" ]]; then
    log_warn "Missing: messages section in .hive.yaml"
    issues_found=$((issues_found + 1))

    if prompt_confirm "Add default messages section to .hive.yaml?"; then
      cat >> "$config" <<'EOF'

# Messages sent to workers (customize these for your workflow)
# Available variables: {lane}, {backlog_count}
messages:
  startup: |
    Read .hive/workers/{lane}/WORKER.md if it exists. You are assigned to lane '{lane}'.
    Check your task backlog. If backlog is EMPTY, report 'No tasks in backlog for {lane}'
    and STOP - do NOT explore or look for other work.
    If tasks exist, claim ONE task and work on it.
    When finished, create a git branch, commit, push, and create a Pull Request.
  nudge: |
    You have {backlog_count} task(s) in your backlog for lane '{lane}'.
    If you have uncommitted changes from a previous task, create a PR first.
    Claim ONE task and work on it.
    When done, create a branch, commit, push, and create a Pull Request.
EOF
      issues_fixed=$((issues_fixed + 1))
      log_ok "Added messages section to .hive.yaml"
    fi
  else
    log_ok "Config has messages section"
  fi

  # Check 6: Offer to regenerate role files with latest template
  echo ""
  if prompt_confirm "Regenerate role files with latest template?"; then
    cmd_role
    log_ok "Regenerated role files"
  fi

  # Check 7: Dependencies
  echo ""
  log_info "Checking dependencies..."
  if check_dependencies "$config"; then
    log_ok "All dependencies installed"
  fi

  # Summary
  echo ""
  if [[ $issues_found -eq 0 ]]; then
    log_ok "No issues found. Hive is healthy!"
  elif [[ $issues_fixed -eq $issues_found ]]; then
    log_ok "Fixed $issues_fixed issue(s). Hive is healthy!"
  else
    log_warn "Found $issues_found issue(s), fixed $issues_fixed"
  fi
}

#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

main() {
  local cmd="${1:-help}"
  shift || true

  case "$cmd" in
    init) cmd_init "$@" ;;
    deinit) cmd_deinit "$@" ;;
    up) cmd_up "$@" ;;
    stop) cmd_stop "$@" ;;
    nudge) cmd_nudge "$@" ;;
    status) cmd_status "$@" ;;
    watch) cmd_watch "$@" ;;
    role) cmd_role "$@" ;;
    doctor) cmd_doctor "$@" ;;
    -h|--help|help) cmd_help ;;
    -v|--version) echo "$SCRIPT_NAME v$VERSION" ;;
    *) log_error "Unknown command: $cmd"; cmd_help; exit 1 ;;
  esac
}

main "$@"
