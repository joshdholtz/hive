#!/usr/bin/env bash
set -euo pipefail

VERSION="1.0.0"
SCRIPT_NAME="hive"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Timing parameters
DEBOUNCE_SECONDS=10
SETTLE_SECONDS=5
GITHUB_POLL_INTERVAL=60
MAX_RETRIES=60
RETRY_INTERVAL=2

# GitHub cache
_GH_ITEMS_CACHE=""
_GH_ITEMS_CACHE_TIME=0

#------------------------------------------------------------------------------
# Utility functions
#------------------------------------------------------------------------------

log_info() { echo -e "${BLUE}[info]${NC} $*"; }
log_ok() { echo -e "${GREEN}[ok]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[warn]${NC} $*"; }
log_error() { echo -e "${RED}[error]${NC} $*" >&2; }

# Portable lowercase (works in bash 3, zsh, etc.)
lowercase() { echo "$1" | tr '[:upper:]' '[:lower:]'; }

# Check if gum is available for fancy prompts
has_gum() { command -v gum &>/dev/null; }

# Run gum command, exit on Ctrl+C
run_gum() {
  local result
  if result=$("$@"); then
    echo "$result"
  else
    local exit_code=$?
    # Exit code 130 = SIGINT (Ctrl+C), 1 = user cancelled
    if [[ $exit_code -eq 130 || $exit_code -eq 1 ]]; then
      echo ""
      log_warn "Cancelled"
      exit 130
    fi
    return $exit_code
  fi
}

#------------------------------------------------------------------------------
# Interactive prompt helpers (gum with fallback)
#------------------------------------------------------------------------------

# Confirm yes/no prompt. Returns 0 for yes, 1 for no.
# Usage: prompt_confirm "Question?" && echo "yes"
prompt_confirm() {
  local prompt="$1"
  local default="${2:-n}"  # y or n

  if has_gum; then
    if [[ "$default" == "y" ]]; then
      gum confirm --default=yes "$prompt" || {
        [[ $? -eq 130 ]] && { echo ""; log_warn "Cancelled"; exit 130; }
        return 1
      }
    else
      gum confirm --default=no "$prompt" || {
        [[ $? -eq 130 ]] && { echo ""; log_warn "Cancelled"; exit 130; }
        return 1
      }
    fi
  else
    local yn
    if [[ "$default" == "y" ]]; then
      read -p "$prompt [Y/n]: " yn
      yn="${yn:-y}"
    else
      read -p "$prompt [y/N]: " yn
      yn="${yn:-n}"
    fi
    [[ "$(lowercase "$yn")" == "y" ]]
  fi
}

# Text input prompt
# Usage: result=$(prompt_input "Prompt" "default" "placeholder")
prompt_input() {
  local prompt="$1"
  local default="${2:-}"
  local placeholder="${3:-$default}"

  if has_gum; then
    local result
    if [[ -n "$default" ]]; then
      result=$(run_gum gum input --header "$prompt" --placeholder "$placeholder" --value "$default")
    else
      result=$(run_gum gum input --header "$prompt" --placeholder "$placeholder")
    fi
    echo "${result:-$default}"
  else
    local result
    if [[ -n "$default" ]]; then
      read -p "$prompt (default: $default): " result
    else
      read -p "$prompt: " result
    fi
    echo "${result:-$default}"
  fi
}

# Single choice from options
# Usage: result=$(prompt_choose "Header" "opt1" "opt2" "opt3")
prompt_choose() {
  local header="$1"
  shift
  local options=("$@")

  if has_gum; then
    run_gum gum choose --header "$header" "${options[@]}"
  else
    echo "$header" >&2
    local i=1
    for opt in "${options[@]}"; do
      echo "  $i) $opt" >&2
      ((i++))
    done
    local choice
    read -p "Enter number: " choice
    if [[ "$choice" =~ ^[0-9]+$ ]] && ((choice >= 1 && choice <= ${#options[@]})); then
      echo "${options[$((choice-1))]}"
    else
      echo "${options[0]}"
    fi
  fi
}

# Multi-select from options (returns newline-separated selections)
# Usage: IFS=$'\n' read -r -d '' -a selected < <(prompt_multi "Header" "${opts[@]}"; printf '\0')
prompt_multi() {
  local header="$1"
  shift
  local options=("$@")

  if has_gum; then
    run_gum gum choose --no-limit --header "$header" "${options[@]}"
  else
    echo "$header" >&2
    local i=1
    for opt in "${options[@]}"; do
      echo "  $i) $opt" >&2
      ((i++))
    done
    echo "Enter numbers separated by commas, ranges (1-3), or 'all'" >&2
    local selection
    read -p "Selection: " selection

    if [[ "$(lowercase "$selection")" == "all" ]]; then
      printf '%s\n' "${options[@]}"
    else
      IFS=',' read -ra parts <<< "$selection"
      for part in "${parts[@]}"; do
        part=$(echo "$part" | tr -d ' ')
        if [[ "$part" == *-* ]]; then
          local start="${part%-*}"
          local end="${part#*-}"
          for ((j=start; j<=end; j++)); do
            [[ $j -ge 1 && $j -le ${#options[@]} ]] && echo "${options[$((j-1))]}"
          done
        elif [[ "$part" =~ ^[0-9]+$ ]]; then
          [[ $part -ge 1 && $part -le ${#options[@]} ]] && echo "${options[$((part-1))]}"
        fi
      done
    fi
  fi
}

# Find .hive.yaml starting from current directory, walking up to root
find_config() {
  local dir="$PWD"
  while [[ "$dir" != "/" ]]; do
    if [[ -f "$dir/.hive.yaml" ]]; then
      echo "$dir/.hive.yaml"
      return 0
    fi
    dir="$(dirname "$dir")"
  done
  return 1
}

# Get project directory (parent of .hive.yaml)
get_project_dir() {
  local config="$1"
  dirname "$config"
}

# Check dependencies
check_dependencies() {
  local config="${1:-}"
  local missing=()

  command -v yq &>/dev/null || missing+=("yq (brew install yq)")
  command -v tmux &>/dev/null || missing+=("tmux (brew install tmux)")
  command -v tmuxp &>/dev/null || missing+=("tmuxp (pip install tmuxp)")

  if [[ -n "$config" && -f "$config" ]]; then
    local backend task_source
    backend=$(yq -r '.backend // "claude"' "$config")
    task_source=$(yq -r '.tasks.source // "yaml"' "$config")

    command -v "$backend" &>/dev/null || missing+=("$backend CLI")

    if [[ "$task_source" == "github" ]]; then
      command -v gh &>/dev/null || missing+=("gh (brew install gh)")
      command -v jq &>/dev/null || missing+=("jq (brew install jq)")
    fi
  fi

  if [[ ${#missing[@]} -gt 0 ]]; then
    log_error "Missing dependencies:"
    for dep in "${missing[@]}"; do
      echo "  - $dep"
    done
    return 1
  fi
  return 0
}

# Validate config file
validate_config() {
  local config="$1"

  if [[ ! -f "$config" ]]; then
    log_error "Config file not found: $config"
    return 1
  fi

  local backend session
  backend=$(yq -r '.backend // ""' "$config")
  session=$(yq -r '.session // ""' "$config")

  if [[ -z "$backend" ]]; then
    log_error "'backend' is required in .hive.yaml (codex or claude)"
    return 1
  fi

  if [[ "$backend" != "codex" && "$backend" != "claude" ]]; then
    log_error "backend must be 'codex' or 'claude', got: $backend"
    return 1
  fi

  if [[ -z "$session" ]]; then
    log_error "'session' is required in .hive.yaml"
    return 1
  fi

  local num_windows
  num_windows=$(yq -r '.windows | length' "$config")
  if [[ "$num_windows" -eq 0 ]]; then
    log_error "At least one window with workers is required"
    return 1
  fi

  return 0
}

#------------------------------------------------------------------------------
# Worker list and task source functions
#------------------------------------------------------------------------------

# Build array of worker specs: "id|window|pane|lane|dir|branch_local|branch_remote"
# Output: one spec per line
build_worker_list() {
  local config="$1"
  local num_windows
  num_windows=$(yq -r '.windows | length' "$config")

  for ((w=0; w<num_windows; w++)); do
    local window_name
    window_name=$(yq -r ".windows[$w].name" "$config")

    local num_workers
    num_workers=$(yq -r ".windows[$w].workers | length" "$config")

    for ((p=0; p<num_workers; p++)); do
      local id lane dir branch_local branch_remote
      id=$(yq -r ".windows[$w].workers[$p].id" "$config")
      lane=$(yq -r ".windows[$w].workers[$p].lane // \"$id\"" "$config")
      dir=$(yq -r ".windows[$w].workers[$p].dir // \".\"" "$config")
      branch_local=$(yq -r ".windows[$w].workers[$p].branch.local // \"\"" "$config")
      branch_remote=$(yq -r ".windows[$w].workers[$p].branch.remote // \"\"" "$config")

      # tmux panes are 1-indexed
      echo "$id|$window_name|$((p + 1))|$lane|$dir|$branch_local|$branch_remote"
    done
  done
}

# Refresh GitHub items cache
gh_refresh_items() {
  local config="$1"

  local project_id org
  project_id=$(yq -r '.tasks.github_project_id // ""' "$config")
  org=$(yq -r '.tasks.github_org // ""' "$config")

  if [[ -z "$project_id" ]]; then
    log_error "github_project_id required for GitHub task source"
    return 1
  fi

  local status_field lane_field
  status_field=$(yq -r '.tasks.github_status_field_id // ""' "$config")
  lane_field=$(yq -r '.tasks.github_lane_field_id // ""' "$config")

  # GraphQL query to fetch project items
  local query
  query=$(cat <<'EOF'
query($projectId: ID!) {
  node(id: $projectId) {
    ... on ProjectV2 {
      items(first: 100) {
        nodes {
          id
          fieldValues(first: 20) {
            nodes {
              ... on ProjectV2ItemFieldSingleSelectValue {
                name
                field { ... on ProjectV2SingleSelectField { name } }
              }
            }
          }
          content {
            ... on DraftIssue { title }
            ... on Issue { title number }
            ... on PullRequest { title number }
          }
        }
      }
    }
  }
}
EOF
)

  _GH_ITEMS_CACHE=$(gh api graphql -f query="$query" -F projectId="$project_id" 2>/dev/null || echo "{}")
  _GH_ITEMS_CACHE_TIME=$(date +%s)
}

# Get task counts for a lane
# Sets backlog_count and in_progress_count variables
get_task_counts() {
  local config="$1"
  local lane="$2"
  local -n _backlog_ref="$3"
  local -n _in_progress_ref="$4"

  local task_source
  task_source=$(yq -r '.tasks.source // "yaml"' "$config")

  if [[ "$task_source" == "github" ]]; then
    # Check cache age
    local now
    now=$(date +%s)
    if [[ -z "$_GH_ITEMS_CACHE" ]] || (( now - _GH_ITEMS_CACHE_TIME > 120 )); then
      gh_refresh_items "$config"
    fi

    # Parse cached items for this lane
    # Count items where Lane == lane AND Status == Backlog
    _backlog_ref=$(echo "$_GH_ITEMS_CACHE" | jq --arg lane "$lane" '
      [.data.node.items.nodes[] |
        select(.fieldValues.nodes[] |
          select(.field.name == "Lane" and .name == $lane)) |
        select(.fieldValues.nodes[] |
          select(.field.name == "Status" and .name == "Backlog"))
      ] | length
    ' 2>/dev/null || echo 0)

    _in_progress_ref=$(echo "$_GH_ITEMS_CACHE" | jq --arg lane "$lane" '
      [.data.node.items.nodes[] |
        select(.fieldValues.nodes[] |
          select(.field.name == "Lane" and .name == $lane)) |
        select(.fieldValues.nodes[] |
          select(.field.name == "Status" and .name == "In progress"))
      ] | length
    ' 2>/dev/null || echo 0)
  else
    # YAML task source
    local tasks_file project_dir
    project_dir=$(get_project_dir "$config")
    tasks_file=$(yq -r '.tasks.file // "./tasks.yaml"' "$config")
    tasks_file="$project_dir/$tasks_file"

    if [[ ! -f "$tasks_file" ]]; then
      _backlog_ref=0
      _in_progress_ref=0
      return
    fi

    # Try different YAML structures
    _backlog_ref=$(yq -r ".\"$lane\".backlog | length // 0" "$tasks_file" 2>/dev/null || echo 0)
    _in_progress_ref=$(yq -r ".\"$lane\".in_progress | length // 0" "$tasks_file" 2>/dev/null || echo 0)

    # Handle null values
    [[ "$_backlog_ref" == "null" ]] && _backlog_ref=0
    [[ "$_in_progress_ref" == "null" ]] && _in_progress_ref=0
  fi
}

#------------------------------------------------------------------------------
# tmuxp generation
#------------------------------------------------------------------------------

generate_tmuxp_config() {
  local config="$1"
  local project_dir
  project_dir=$(get_project_dir "$config")

  local backend session
  backend=$(yq -r '.backend' "$config")
  session=$(yq -r '.session' "$config")

  local tmuxp_file
  tmuxp_file=$(mktemp)

  # Start YAML
  cat > "$tmuxp_file" <<EOF
session_name: $session
options:
  pane-border-status: top
  pane-border-format: " #{pane_title} "
windows:
EOF

  # Iterate windows
  local num_windows
  num_windows=$(yq -r '.windows | length' "$config")

  for ((w=0; w<num_windows; w++)); do
    local window_name layout
    window_name=$(yq -r ".windows[$w].name" "$config")
    layout=$(yq -r ".windows[$w].layout // \"even-horizontal\"" "$config")

    cat >> "$tmuxp_file" <<EOF
  - window_name: $window_name
    layout: $layout
    panes:
EOF

    local num_workers
    num_workers=$(yq -r ".windows[$w].workers | length" "$config")

    for ((p=0; p<num_workers; p++)); do
      local worker_id worker_dir worker_lane
      worker_id=$(yq -r ".windows[$w].workers[$p].id" "$config")
      worker_dir=$(yq -r ".windows[$w].workers[$p].dir // \".\"" "$config")
      worker_lane=$(yq -r ".windows[$w].workers[$p].lane // \"$worker_id\"" "$config")

      # Resolve to absolute path
      local abs_dir="$project_dir/$worker_dir"
      abs_dir=$(cd "$abs_dir" 2>/dev/null && pwd || echo "$abs_dir")

      # Build agent command
      local agent_cmd initial_msg
      initial_msg="Read CLAUDE_ROLE.md if it exists. You are assigned to lane '$worker_lane'. Check your task backlog, claim ONE task, and work on it. Push a PR when done."

      if [[ "$backend" == "codex" ]]; then
        agent_cmd="env -u CODEX_SANDBOX -u CODEX_SANDBOX_NETWORK_DISABLED codex --sandbox danger-full-access --ask-for-approval \"never\" \"$initial_msg\""
      else
        agent_cmd="claude \"$initial_msg\""
      fi

      cat >> "$tmuxp_file" <<EOF
      - shell_command:
          - tmux select-pane -T "$worker_id"
          - cd "$abs_dir"
          - $agent_cmd
EOF
    done
  done

  # Add watch window
  cat >> "$tmuxp_file" <<EOF
  - window_name: watch
    panes:
      - shell_command:
          - tmux select-pane -T "watcher"
          - cd "$project_dir"
          - hive watch
EOF

  echo "$tmuxp_file"
}

#------------------------------------------------------------------------------
# Commands
#------------------------------------------------------------------------------

cmd_help() {
  cat <<EOF
${SCRIPT_NAME} v${VERSION} - AI Worker Orchestration

USAGE:
    ${SCRIPT_NAME} <command> [options]

COMMANDS:
    init              Create .hive.yaml interactively
    up                Start worker session
    stop              Stop worker session
    nudge [worker]    Nudge idle workers (or specific one)
    status            Show worker status and task counts
    watch             Run watcher loop (internal, run by 'up')
    role [worker]     Generate CLAUDE_ROLE.md for worker(s)
    help              Show this help

EXAMPLES:
    ${SCRIPT_NAME} init                  # Create config interactively
    ${SCRIPT_NAME} up                    # Start all workers
    ${SCRIPT_NAME} status                # Check worker status
    ${SCRIPT_NAME} nudge backend-a       # Nudge specific worker
    ${SCRIPT_NAME} stop                  # Stop all workers

CONFIG:
    Place .hive.yaml in your project root. See 'hive init' to create one.
EOF
}

cmd_up() {
  local config
  config=$(find_config) || { log_error "No .hive.yaml found. Run 'hive init' first."; exit 1; }

  check_dependencies "$config" || exit 1
  validate_config "$config" || exit 1

  local session backend
  session=$(yq -r '.session' "$config")
  backend=$(yq -r '.backend' "$config")

  # Check if session already exists
  if tmux has-session -t "$session" 2>/dev/null; then
    log_warn "Session '$session' already running"
    if prompt_confirm "Kill and restart?"; then
      tmux kill-session -t "$session"
    else
      echo "Use 'hive stop' first, or attach with: tmux attach -t $session"
      exit 1
    fi
  fi

  # Clear codex env vars if needed
  if [[ "$backend" == "codex" ]]; then
    tmux set-environment -gu CODEX_SANDBOX 2>/dev/null || true
    tmux set-environment -gu CODEX_SANDBOX_NETWORK_DISABLED 2>/dev/null || true
  fi

  # Generate and load tmuxp config
  log_info "Generating tmux configuration..."
  local tmuxp_file
  tmuxp_file=$(generate_tmuxp_config "$config")

  log_info "Starting session: $session"
  tmuxp load "$tmuxp_file"

  rm -f "$tmuxp_file"

  # Brief delay then initial nudge
  sleep 0.6
  cmd_nudge || true

  log_ok "Session started"
  echo "Attach with: tmux attach -t $session"
}

cmd_stop() {
  local config
  config=$(find_config) || { log_error "No .hive.yaml found"; exit 1; }

  local session
  session=$(yq -r '.session' "$config")

  if tmux has-session -t "$session" 2>/dev/null; then
    log_info "Stopping session: $session"
    tmux kill-session -t "$session"
    log_ok "Session stopped"
  else
    log_warn "Session '$session' not running"
  fi
}

cmd_nudge() {
  local specific_worker="${1:-}"

  local config
  config=$(find_config) || { log_error "No .hive.yaml found"; exit 1; }

  local session task_source
  session=$(yq -r '.session' "$config")
  task_source=$(yq -r '.tasks.source // "yaml"' "$config")

  # Verify session exists
  if ! tmux has-session -t "$session" 2>/dev/null; then
    log_error "Session '$session' not running"
    return 1
  fi

  log_info "Analyzing workers... (source: $task_source)"

  # Pre-fetch GitHub items if needed
  if [[ "$task_source" == "github" ]]; then
    gh_refresh_items "$config" || true
  fi

  local nudged=0

  while IFS='|' read -r id window pane lane dir branch_local branch_remote; do
    [[ -z "$id" ]] && continue

    # Skip if targeting specific worker and this isn't it
    [[ -n "$specific_worker" && "$id" != "$specific_worker" ]] && continue

    # Get task counts
    local backlog_count=0 in_progress_count=0
    get_task_counts "$config" "$lane" backlog_count in_progress_count

    # Only nudge if has backlog and not busy
    if [[ "$backlog_count" -gt 0 && "$in_progress_count" -eq 0 ]]; then
      # Build nudge message
      local msg="FIRST: If you have uncommitted changes or an unpushed branch from a previous task, push it to a PR NOW before starting anything new. You have $backlog_count task(s) in your backlog for lane '$lane'. Claim ONE task and work on it."

      # Add branch naming convention if configured
      if [[ -n "$branch_local" && -n "$branch_remote" ]]; then
        msg="$msg IMPORTANT: Your LOCAL branch names MUST start with '$branch_local/' (e.g. '$branch_local/my-feature'). Push to remote with: git push origin $branch_local/my-feature:$branch_remote/my-feature"
      fi

      # Send to tmux pane
      tmux send-keys -t "$session:$window.$pane" -l "$msg"
      sleep 0.1
      tmux send-keys -t "$session:$window.$pane" Enter

      echo "  -> $id ($window:$pane): $backlog_count task(s)"
      nudged=1
    fi
  done < <(build_worker_list "$config")

  if [[ $nudged -eq 1 ]]; then
    log_ok "Nudged idle workers with pending tasks"
  else
    log_info "No idle workers with pending tasks"
  fi
}

cmd_status() {
  local config
  config=$(find_config) || { log_error "No .hive.yaml found"; exit 1; }

  local session task_source backend
  session=$(yq -r '.session' "$config")
  task_source=$(yq -r '.tasks.source // "yaml"' "$config")
  backend=$(yq -r '.backend' "$config")

  echo ""
  echo "Session: $session"
  echo "Backend: $backend"
  echo "Task Source: $task_source"

  if tmux has-session -t "$session" 2>/dev/null; then
    echo -e "Status: ${GREEN}RUNNING${NC}"
  else
    echo -e "Status: ${RED}STOPPED${NC}"
  fi
  echo ""

  # Pre-fetch GitHub items if needed
  if [[ "$task_source" == "github" ]]; then
    gh_refresh_items "$config" || true
  fi

  # Worker table header
  printf "%-20s %-15s %-10s %-12s\n" "WORKER" "LANE" "BACKLOG" "IN_PROGRESS"
  printf "%-20s %-15s %-10s %-12s\n" "------" "----" "-------" "-----------"

  while IFS='|' read -r id window pane lane dir branch_local branch_remote; do
    [[ -z "$id" ]] && continue

    local backlog_count=0 in_progress_count=0
    get_task_counts "$config" "$lane" backlog_count in_progress_count

    printf "%-20s %-15s %-10s %-12s\n" "$id" "$lane" "$backlog_count" "$in_progress_count"
  done < <(build_worker_list "$config")

  echo ""
}

cmd_watch() {
  local config
  config=$(find_config) || { log_error "No .hive.yaml found"; exit 1; }

  local session task_source
  session=$(yq -r '.session' "$config")
  task_source=$(yq -r '.tasks.source // "yaml"' "$config")

  log_info "Hive watcher starting..."
  log_info "Task source: $task_source"

  # Wait for all windows to be ready
  log_info "Waiting for windows..."
  local retries=0
  while true; do
    local all_ready=1
    local num_windows
    num_windows=$(yq -r '.windows | length' "$config")

    for ((w=0; w<num_windows; w++)); do
      local window_name
      window_name=$(yq -r ".windows[$w].name" "$config")

      if ! tmux list-windows -t "$session" -F "#{window_name}" 2>/dev/null | grep -qx "$window_name"; then
        all_ready=0
        break
      fi
    done

    [[ $all_ready -eq 1 ]] && break

    retries=$((retries + 1))
    if ((retries > MAX_RETRIES)); then
      log_error "Timeout waiting for windows"
      exit 1
    fi

    sleep "$RETRY_INTERVAL"
  done
  log_ok "All windows ready"

  # Initial nudge
  cmd_nudge || true

  # Watch loop
  local last_nudge=0

  if [[ "$task_source" == "github" ]]; then
    log_info "Polling GitHub every ${GITHUB_POLL_INTERVAL}s"
    echo "Press Ctrl+C to stop"
    echo ""

    while true; do
      sleep "$GITHUB_POLL_INTERVAL"
      echo "[$(date +%H:%M:%S)] Polling GitHub..."
      cmd_nudge 2>/dev/null || true
    done
  else
    local tasks_file project_dir
    project_dir=$(get_project_dir "$config")
    tasks_file=$(yq -r '.tasks.file // "./tasks.yaml"' "$config")
    tasks_file="$project_dir/$tasks_file"

    if command -v fswatch &>/dev/null; then
      log_info "Watching: $tasks_file (fswatch)"
      echo "Press Ctrl+C to stop"
      echo ""

      fswatch -o "$tasks_file" 2>/dev/null | while read -r _; do
        local now
        now=$(date +%s)
        local elapsed=$((now - last_nudge))

        if (( elapsed < DEBOUNCE_SECONDS )); then
          echo "[$(date +%H:%M:%S)] Change detected, debouncing..."
          continue
        fi

        echo "[$(date +%H:%M:%S)] File changed, waiting to settle..."
        sleep "$SETTLE_SECONDS"

        last_nudge=$(date +%s)
        cmd_nudge 2>/dev/null || true
      done
    else
      log_info "Watching: $tasks_file (polling)"
      log_warn "Install fswatch for better performance: brew install fswatch"
      echo "Press Ctrl+C to stop"
      echo ""

      local last_mtime
      last_mtime=$(stat -f %m "$tasks_file" 2>/dev/null || stat -c %Y "$tasks_file" 2>/dev/null || echo 0)

      while true; do
        sleep 1
        local mtime
        mtime=$(stat -f %m "$tasks_file" 2>/dev/null || stat -c %Y "$tasks_file" 2>/dev/null || echo 0)

        if [[ "$mtime" != "$last_mtime" ]]; then
          last_mtime="$mtime"

          local now
          now=$(date +%s)
          local elapsed=$((now - last_nudge))

          if (( elapsed < DEBOUNCE_SECONDS )); then
            echo "[$(date +%H:%M:%S)] Change detected, debouncing..."
            continue
          fi

          echo "[$(date +%H:%M:%S)] File changed, waiting to settle..."
          sleep "$SETTLE_SECONDS"

          last_nudge=$(date +%s)
          cmd_nudge 2>/dev/null || true
        fi
      done
    fi
  fi
}

cmd_init() {
  if has_gum; then
    gum style --border double --padding "0 2" --border-foreground 212 "Hive Configuration Wizard"
  else
    echo ""
    echo "Hive Configuration Wizard"
    echo "========================="
  fi
  echo ""

  # Check if config already exists
  if [[ -f ".hive.yaml" ]]; then
    log_warn ".hive.yaml already exists"
    prompt_confirm "Overwrite existing config?" || exit 0
  fi

  # Step 1: Backend
  local backend
  backend=$(prompt_choose "Select AI backend:" "claude" "codex")

  # Step 2: Session name
  local default_session
  default_session=$(basename "$PWD" | tr '[:upper:]' '[:lower:]' | tr ' _' '-')
  local session
  session=$(prompt_input "Session name" "$default_session")

  # Step 3: Task source
  local task_source
  task_source=$(prompt_choose "Select task source:" "yaml" "github")

  local tasks_file="" github_project="" github_org="" github_project_id=""
  local github_status_field="" github_lane_field=""

  if [[ "$task_source" == "github" ]]; then
    github_org=$(prompt_input "GitHub org name" "" "my-org")
    github_project=$(prompt_input "GitHub Project number" "" "1")
    github_project_id=$(prompt_input "GitHub Project ID" "" "PVT_...")
    github_status_field=$(prompt_input "Status field ID" "" "PVTSSF_...")
    github_lane_field=$(prompt_input "Lane field ID" "" "PVTSSF_...")
  else
    tasks_file=$(prompt_input "Tasks file path" "./tasks.yaml")
  fi

  # Step 4: Scan and select directories
  echo ""
  log_info "Scanning for subdirectories..."

  local -a available_dirs=()
  local -a display_names=()

  for d in */; do
    [[ ! -d "$d" ]] && continue
    local name="${d%/}"

    # Skip common non-worker directories
    [[ "$name" == "node_modules" || "$name" == ".git" || "$name" == "vendor" || "$name" == "dist" || "$name" == "build" ]] && continue

    available_dirs+=("$name")
    if [[ -d "$d/.git" ]]; then
      display_names+=("$name [git]")
    else
      display_names+=("$name")
    fi
  done

  local -a workers=()
  local -a worker_ids=()
  local -a pending_worktrees=()

  if [[ ${#available_dirs[@]} -eq 0 ]]; then
    log_warn "No subdirectories found."
  else
    # Multi-select directories
    echo ""
    local -a selected_display=()
    IFS=$'\n' read -r -d '' -a selected_display < <(prompt_multi "Select directories to include as workers:" "${display_names[@]}"; printf '\0') || true

    # Configure each selected directory
    for sel in "${selected_display[@]}"; do
      [[ -z "$sel" ]] && continue

      # Check if this is a git repo (display name ends with " [git]")
      local is_git=0
      local name="$sel"
      if [[ "$sel" == *" [git]" ]]; then
        is_git=1
        name="${sel% \[git\]}"
      fi

      echo ""
      if has_gum; then
        gum style --foreground 212 "Configuring: $name"
      else
        echo "--- Configuring: $name ---"
      fi

      # If it's a git repo, offer to create worktrees
      if [[ "$is_git" == "1" ]]; then
        if prompt_confirm "Create git worktrees for parallel workers?"; then
          local num_workers
          num_workers=$(prompt_input "How many workers?" "3")

          log_info "Configuring $num_workers worktrees (will be created at end)..."
          local letters=(a b c d e f g h i j)

          # Store worktree request for later creation
          pending_worktrees+=("$name|$num_workers")

          for ((i=0; i<num_workers; i++)); do
            local letter="${letters[$i]}"
            local wt_name="${name}-${letter}"

            echo ""
            echo "Worker: $wt_name"
            echo "  Purpose is used to assign tasks and name branches."
            echo "  Example: 'api' creates branches like ${name}-${letter}/api/add-endpoint"
            local purpose
            purpose=$(prompt_input "Purpose/lane for $wt_name" "$name")

            # Auto-generate branch prefixes from purpose
            local branch_local="${name}-${letter}/${purpose}"
            local branch_remote="${letter}/${purpose}"

            workers+=("$wt_name|$purpose|$branch_local|$branch_remote")
            worker_ids+=("$wt_name")
          done

          continue  # Skip adding the original repo as a worker
        fi
      fi

      # Regular (non-worktree) worker
      local lane
      lane=$(prompt_input "Lane name" "$name")

      workers+=("$name|$lane||")
      worker_ids+=("$name")
    done
  fi

  if [[ ${#workers[@]} -eq 0 ]]; then
    log_warn "No workers added. Creating minimal config."
  fi

  # Step 5: Group into windows
  echo ""
  local -a windows=()

  if [[ ${#workers[@]} -gt 0 ]]; then
    if prompt_confirm "Group all workers into one window?" "y"; then
      local window_name
      window_name=$(prompt_input "Window name" "workers")
      windows+=("$window_name|${worker_ids[*]}")
    else
      log_info "Configure window groupings (select workers for each window)"
      while true; do
        local win_name
        win_name=$(prompt_input "Window name" "" "enter name or leave empty to finish")
        [[ -z "$win_name" || "$win_name" == "enter name or leave empty to finish" ]] && break

        # Let user select workers for this window
        local -a win_worker_selection=()
        IFS=$'\n' read -r -d '' -a win_worker_selection < <(prompt_multi "Select workers for '$win_name':" "${worker_ids[@]}"; printf '\0') || true

        if [[ ${#win_worker_selection[@]} -gt 0 ]]; then
          local win_workers_str="${win_worker_selection[*]}"
          windows+=("$win_name|$win_workers_str")
        fi
      done
    fi
  fi

  # Step 6: Generate config
  echo ""
  log_info "Generating .hive.yaml..."

  cat > .hive.yaml <<EOF
backend: $backend
session: $session

tasks:
  source: $task_source
EOF

  if [[ "$task_source" == "github" ]]; then
    cat >> .hive.yaml <<EOF
  github_org: $github_org
  github_project: $github_project
  github_project_id: $github_project_id
  github_status_field_id: $github_status_field
  github_lane_field_id: $github_lane_field
EOF
  else
    cat >> .hive.yaml <<EOF
  file: $tasks_file
EOF
  fi

  if [[ ${#windows[@]} -gt 0 ]]; then
    cat >> .hive.yaml <<EOF

windows:
EOF

    for win_spec in "${windows[@]}"; do
      IFS='|' read -r win_name win_worker_list <<< "$win_spec"

      cat >> .hive.yaml <<EOF
  - name: $win_name
    layout: even-horizontal
    workers:
EOF

      # Find workers for this window
      for worker_spec in "${workers[@]}"; do
        IFS='|' read -r w_id w_lane w_bl w_br <<< "$worker_spec"

        # Check if this worker is in this window
        if [[ " $win_worker_list " == *" $w_id "* ]] || [[ "$win_worker_list" == *"$w_id"* ]]; then
          cat >> .hive.yaml <<EOF
      - id: $w_id
        dir: ./$w_id
        lane: $w_lane
EOF
          if [[ -n "$w_bl" || -n "$w_br" ]]; then
            cat >> .hive.yaml <<EOF
        branch:
          local: "$w_bl"
          remote: "$w_br"
EOF
          fi
        fi
      done
    done
  else
    # Create placeholder window
    cat >> .hive.yaml <<EOF

windows:
  - name: workers
    layout: even-horizontal
    workers:
      - id: example
        dir: .
        lane: default
EOF
  fi

  # Create any pending worktrees now that config is complete
  if [[ ${#pending_worktrees[@]} -gt 0 ]]; then
    echo ""
    log_info "Creating git worktrees..."
    local letters=(a b c d e f g h i j)

    for wt_request in "${pending_worktrees[@]}"; do
      IFS='|' read -r source_dir num_wt <<< "$wt_request"

      for ((i=0; i<num_wt; i++)); do
        local letter="${letters[$i]}"
        local wt_name="${source_dir}-${letter}"
        local wt_path="$PWD/$wt_name"

        if [[ ! -d "$wt_path" ]]; then
          # Create worktree with a new branch
          local branch_name="worker-${letter}"
          if (cd "$source_dir" && git worktree add "$wt_path" -b "$branch_name" 2>/dev/null) || \
             (cd "$source_dir" && git worktree add "$wt_path" HEAD 2>/dev/null); then
            echo "  Created worktree: $wt_name"
          else
            log_warn "  Failed to create worktree: $wt_name"
          fi
        else
          echo "  Worktree exists: $wt_name"
        fi
      done
    done
  fi

  log_ok "Created .hive.yaml"
  echo ""

  # Offer to generate role files
  if [[ ${#workers[@]} -gt 0 ]]; then
    if prompt_confirm "Generate CLAUDE_ROLE.md files for workers?" "y"; then
      cmd_role
    fi
  fi

  echo ""
  if has_gum; then
    gum style --foreground 10 "Next steps:"
    echo "  1. Review .hive.yaml"
    echo "  2. Run 'hive up' to start workers"
  else
    echo "Next steps:"
    echo "  1. Review .hive.yaml"
    echo "  2. Run 'hive up' to start workers"
  fi
}

cmd_role() {
  local specific_worker="${1:-}"

  local config
  config=$(find_config) || { log_error "No .hive.yaml found"; exit 1; }

  local project_dir task_source
  project_dir=$(get_project_dir "$config")
  task_source=$(yq -r '.tasks.source // "yaml"' "$config")

  while IFS='|' read -r id window pane lane dir branch_local branch_remote; do
    [[ -z "$id" ]] && continue

    # Skip if targeting specific worker
    [[ -n "$specific_worker" && "$id" != "$specific_worker" ]] && continue

    local abs_dir="$project_dir/$dir"
    local role_file="$abs_dir/CLAUDE_ROLE.md"

    # Check if custom content exists
    local custom_content=""
    if [[ -f "$role_file" ]]; then
      # Extract content after "## Project-Specific Instructions"
      custom_content=$(sed -n '/^## Project-Specific Instructions/,$p' "$role_file" | tail -n +2)
    fi

    log_info "Generating $role_file"

    cat > "$role_file" <<EOF
# Worker Role: $id

You are a background worker assigned to lane **$lane**.

## General Behavior
1. Check your task backlog and claim ONE task at a time
2. Implement the task completely
3. Push your work to a PR before claiming the next task
4. If you have uncommitted changes from a previous task, push them first
5. Do NOT start a new task until the previous one has a PR created

EOF

    # Add branch naming if configured
    if [[ -n "$branch_local" && -n "$branch_remote" ]]; then
      cat >> "$role_file" <<EOF
## Branch Naming Convention
- Create local branches with prefix: \`$branch_local/\`
- Example: \`$branch_local/my-feature\`
- Push command: \`git push origin $branch_local/my-feature:$branch_remote/my-feature\`

EOF
    fi

    # Add task source instructions
    if [[ "$task_source" == "github" ]]; then
      local github_project
      github_project=$(yq -r '.tasks.github_project // ""' "$config")
      cat >> "$role_file" <<EOF
## Task Source
Tasks are managed in GitHub Project #$github_project.
- View your lane's backlog in the project board
- Move tasks to "In Progress" when you start
- Move tasks to "Done" when PR is merged

EOF
    else
      local tasks_file
      tasks_file=$(yq -r '.tasks.file // "./tasks.yaml"' "$config")
      cat >> "$role_file" <<EOF
## Task Source
Tasks are managed in \`$tasks_file\`.
- Your lane: \`$lane\`
- Check the \`backlog\` section for pending tasks
- Move tasks to \`in_progress\` when you start
- Move tasks to \`done\` when complete

EOF
    fi

    # Add custom content section
    cat >> "$role_file" <<EOF
---
## Project-Specific Instructions
<!-- Add your custom instructions below this line -->
EOF

    if [[ -n "$custom_content" ]]; then
      echo "$custom_content" >> "$role_file"
    else
      echo "" >> "$role_file"
    fi

  done < <(build_worker_list "$config")

  log_ok "Role files generated"
}

#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

main() {
  local cmd="${1:-help}"
  shift || true

  case "$cmd" in
    init) cmd_init "$@" ;;
    up) cmd_up "$@" ;;
    stop) cmd_stop "$@" ;;
    nudge) cmd_nudge "$@" ;;
    status) cmd_status "$@" ;;
    watch) cmd_watch "$@" ;;
    role) cmd_role "$@" ;;
    -h|--help|help) cmd_help ;;
    -v|--version) echo "$SCRIPT_NAME v$VERSION" ;;
    *) log_error "Unknown command: $cmd"; cmd_help; exit 1 ;;
  esac
}

main "$@"
